<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Types that are IEEE754 floating point numbers."><title>Ieee754 in ieee754 - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ieee754" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../ieee754/index.html">ieee754</a><span class="version">0.2.6</span></h2></div><h2 class="location"><a href="#">Ieee754</a></h2><div class="sidebar-elems"><section><h3><a href="#required-associated-types">Required Associated Types</a></h3><ul class="block"><li><a href="#associatedtype.Bits">Bits</a></li><li><a href="#associatedtype.Exponent">Exponent</a></li><li><a href="#associatedtype.RawExponent">RawExponent</a></li><li><a href="#associatedtype.Significand">Significand</a></li></ul><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.abs">abs</a></li><li><a href="#tymethod.bits">bits</a></li><li><a href="#tymethod.copy_sign">copy_sign</a></li><li><a href="#tymethod.decompose">decompose</a></li><li><a href="#tymethod.decompose_raw">decompose_raw</a></li><li><a href="#tymethod.exponent_bias">exponent_bias</a></li><li><a href="#tymethod.from_bits">from_bits</a></li><li><a href="#tymethod.next">next</a></li><li><a href="#tymethod.prev">prev</a></li><li><a href="#tymethod.recompose">recompose</a></li><li><a href="#tymethod.recompose_raw">recompose_raw</a></li><li><a href="#tymethod.rel_error">rel_error</a></li><li><a href="#tymethod.sign">sign</a></li><li><a href="#tymethod.total_cmp">total_cmp</a></li><li><a href="#tymethod.ulp">ulp</a></li><li><a href="#tymethod.upto">upto</a></li></ul><h3><a href="#foreign-impls">Implementations on Foreign Types</a></h3><ul class="block"><li><a href="#impl-Ieee754-for-f32">f32</a></li><li><a href="#impl-Ieee754-for-f64">f64</a></li></ul><h3><a href="#object-safety">Object Safety</a></h3><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In crate ieee754</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="index.html">ieee754</a>::<wbr><a class="trait" href="#">Ieee754</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/ieee754/traits.rs.html#16-685">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait Ieee754: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> + <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a> + <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a> {
    type <a href="#associatedtype.Bits" class="associatedtype">Bits</a>: <a class="trait" href="trait.Bits.html" title="trait ieee754::Bits">Bits</a>;
    type <a href="#associatedtype.Exponent" class="associatedtype">Exponent</a>;
    type <a href="#associatedtype.RawExponent" class="associatedtype">RawExponent</a>;
    type <a href="#associatedtype.Significand" class="associatedtype">Significand</a>;

<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 16 methods</span></summary>    // Required methods
    fn <a href="#tymethod.upto" class="fn">upto</a>(self, lim: Self) -&gt; <a class="struct" href="struct.Iter.html" title="struct ieee754::Iter">Iter</a>&lt;Self&gt; <a href="#" class="tooltip" data-notable-ty="Iter&lt;Self&gt;">ⓘ</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.next" class="fn">next</a>(self) -&gt; Self;
<span class="item-spacer"></span>    fn <a href="#tymethod.prev" class="fn">prev</a>(self) -&gt; Self;
<span class="item-spacer"></span>    fn <a href="#tymethod.ulp" class="fn">ulp</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.bits" class="fn">bits</a>(self) -&gt; Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Bits" title="type ieee754::Ieee754::Bits">Bits</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.from_bits" class="fn">from_bits</a>(x: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Bits" title="type ieee754::Ieee754::Bits">Bits</a>) -&gt; Self;
<span class="item-spacer"></span>    fn <a href="#tymethod.exponent_bias" class="fn">exponent_bias</a>() -&gt; Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Exponent" title="type ieee754::Ieee754::Exponent">Exponent</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.decompose_raw" class="fn">decompose_raw</a>(self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.bool.html">bool</a>, Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.RawExponent" title="type ieee754::Ieee754::RawExponent">RawExponent</a>, Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Significand" title="type ieee754::Ieee754::Significand">Significand</a>);
<span class="item-spacer"></span>    fn <a href="#tymethod.recompose_raw" class="fn">recompose_raw</a>(
        sign: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.bool.html">bool</a>,
        expn: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.RawExponent" title="type ieee754::Ieee754::RawExponent">RawExponent</a>,
        signif: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Significand" title="type ieee754::Ieee754::Significand">Significand</a>,
    ) -&gt; Self;
<span class="item-spacer"></span>    fn <a href="#tymethod.decompose" class="fn">decompose</a>(self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.bool.html">bool</a>, Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Exponent" title="type ieee754::Ieee754::Exponent">Exponent</a>, Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Significand" title="type ieee754::Ieee754::Significand">Significand</a>);
<span class="item-spacer"></span>    fn <a href="#tymethod.recompose" class="fn">recompose</a>(
        sign: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.bool.html">bool</a>,
        expn: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Exponent" title="type ieee754::Ieee754::Exponent">Exponent</a>,
        signif: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Significand" title="type ieee754::Ieee754::Significand">Significand</a>,
    ) -&gt; Self;
<span class="item-spacer"></span>    fn <a href="#tymethod.total_cmp" class="fn">total_cmp</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.reference.html">&amp;Self</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.abs" class="fn">abs</a>(self) -&gt; Self;
<span class="item-spacer"></span>    fn <a href="#tymethod.copy_sign" class="fn">copy_sign</a>(self, sign: Self) -&gt; Self;
<span class="item-spacer"></span>    fn <a href="#tymethod.sign" class="fn">sign</a>(self) -&gt; Self;
<span class="item-spacer"></span>    fn <a href="#tymethod.rel_error" class="fn">rel_error</a>(self, exact: Self) -&gt; Self;
</details>}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Types that are IEEE754 floating point numbers.</p>
</div></details><h2 id="required-associated-types" class="section-header">Required Associated Types<a href="#required-associated-types" class="anchor">§</a></h2><div class="methods"><details class="toggle" open><summary><section id="associatedtype.Bits" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#38">source</a><h4 class="code-header">type <a href="#associatedtype.Bits" class="associatedtype">Bits</a>: <a class="trait" href="trait.Bits.html" title="trait ieee754::Bits">Bits</a></h4></section></summary><div class="docblock"><p>A type that represents the raw bits of <code>Self</code>.</p>
</div></details><details class="toggle" open><summary><section id="associatedtype.Exponent" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#40">source</a><h4 class="code-header">type <a href="#associatedtype.Exponent" class="associatedtype">Exponent</a></h4></section></summary><div class="docblock"><p>A type large enough to store the true exponent of <code>Self</code>.</p>
</div></details><details class="toggle" open><summary><section id="associatedtype.RawExponent" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#42">source</a><h4 class="code-header">type <a href="#associatedtype.RawExponent" class="associatedtype">RawExponent</a></h4></section></summary><div class="docblock"><p>A type large enough to store the raw exponent (i.e. with the bias).</p>
</div></details><details class="toggle" open><summary><section id="associatedtype.Significand" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#44">source</a><h4 class="code-header">type <a href="#associatedtype.Significand" class="associatedtype">Significand</a></h4></section></summary><div class="docblock"><p>A type large enough to store the significand of <code>Self</code>.</p>
</div></details></div><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.upto" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#35">source</a><h4 class="code-header">fn <a href="#tymethod.upto" class="fn">upto</a>(self, lim: Self) -&gt; <a class="struct" href="struct.Iter.html" title="struct ieee754::Iter">Iter</a>&lt;Self&gt; <a href="#" class="tooltip" data-notable-ty="Iter&lt;Self&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Iterate over each value of <code>Self</code> in <code>[self, lim]</code>.</p>
<p>The returned iterator will include subnormal numbers, and will
only include one of <code>-0.0</code> and <code>0.0</code>.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>Panics if <code>self &gt; lim</code>, or if either are NaN.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ieee754::Ieee754;

<span class="comment">// there are 840 single-precision floats in between 1.0 and 1.0001
// (inclusive).
</span><span class="macro">assert_eq!</span>(<span class="number">1_f32</span>.upto(<span class="number">1.0001</span>).count(), <span class="number">840</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.next" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#57">source</a><h4 class="code-header">fn <a href="#tymethod.next" class="fn">next</a>(self) -&gt; Self</h4></section></summary><div class="docblock"><p>Return the next value after <code>self</code>.</p>
<p>Calling this on NaN or positive infinity will yield nonsense.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ieee754::Ieee754;
<span class="kw">let </span>x: f32 = <span class="number">1.0</span>;
<span class="macro">assert_eq!</span>(x.next(), <span class="number">1.000000119209</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.prev" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#70">source</a><h4 class="code-header">fn <a href="#tymethod.prev" class="fn">prev</a>(self) -&gt; Self</h4></section></summary><div class="docblock"><p>Return the previous value before <code>self</code>.</p>
<p>Calling this on NaN or negative infinity will yield nonsense.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ieee754::Ieee754;
<span class="kw">let </span>x: f32 = <span class="number">1.0</span>;
<span class="macro">assert_eq!</span>(x.prev(), <span class="number">0.99999995</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.ulp" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#124">source</a><h4 class="code-header">fn <a href="#tymethod.ulp" class="fn">ulp</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Return the unit-in-the-last-place ulp of <code>self</code>. That is,
<code>x.abs().next() - x.abs()</code>, but handling overflow properly.</p>
<p>Returns <code>None</code> if <code>self</code> is not finite.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h5>
<p>Single precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::f32;
<span class="kw">use </span>ieee754::Ieee754;

<span class="macro">assert_eq!</span>(<span class="number">0_f32</span>.ulp(), <span class="prelude-val">Some</span>(<span class="number">1.4e-45</span>));

<span class="macro">assert_eq!</span>(<span class="number">1_f32</span>.ulp(), <span class="prelude-val">Some</span>(<span class="number">1.1920928955078125e-07</span>));
<span class="macro">assert_eq!</span>((-<span class="number">1_f32</span>).ulp(), <span class="prelude-val">Some</span>(<span class="number">1.1920928955078125e-07</span>));

<span class="comment">// 2^23
</span><span class="macro">assert_eq!</span>(<span class="number">8_388_608_f32</span>.ulp(), <span class="prelude-val">Some</span>(<span class="number">1.0</span>));
<span class="comment">// 2^24 - 1, the largest f32 with ULP 1
</span><span class="macro">assert_eq!</span>(<span class="number">16_777_215_f32</span>.ulp(), <span class="prelude-val">Some</span>(<span class="number">1.0</span>));
<span class="comment">// 2^24
</span><span class="macro">assert_eq!</span>(<span class="number">16_777_216_f32</span>.ulp(), <span class="prelude-val">Some</span>(<span class="number">2.0</span>));

<span class="comment">// non-finite
</span><span class="macro">assert_eq!</span>(f32::INFINITY.ulp(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(f32::NAN.ulp(), <span class="prelude-val">None</span>);</code></pre></div>
<p>Double precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::f64;
<span class="kw">use </span>ieee754::Ieee754;

<span class="macro">assert_eq!</span>(<span class="number">0_f64</span>.ulp(), <span class="prelude-val">Some</span>(<span class="number">4.9e-324</span>));

<span class="macro">assert_eq!</span>(<span class="number">1_f64</span>.ulp(), <span class="prelude-val">Some</span>(<span class="number">2.220446049250313e-16</span>));
<span class="macro">assert_eq!</span>((-<span class="number">1_f64</span>).ulp(), <span class="prelude-val">Some</span>(<span class="number">2.220446049250313e-16</span>));

<span class="comment">// 2^52
</span><span class="macro">assert_eq!</span>(<span class="number">4_503_599_627_370_496_f64</span>.ulp(), <span class="prelude-val">Some</span>(<span class="number">1.0</span>));
<span class="comment">// 2^53 - 1, the largest f64 with ULP 1
</span><span class="macro">assert_eq!</span>(<span class="number">9_007_199_254_740_991_f64</span>.ulp(), <span class="prelude-val">Some</span>(<span class="number">1.0</span>));
<span class="comment">// 2^53
</span><span class="macro">assert_eq!</span>(<span class="number">9_007_199_254_740_992_f64</span>.ulp(), <span class="prelude-val">Some</span>(<span class="number">2.0</span>));

<span class="comment">// non-finite
</span><span class="macro">assert_eq!</span>(f64::INFINITY.ulp(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(f64::NAN.ulp(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.bits" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#135">source</a><h4 class="code-header">fn <a href="#tymethod.bits" class="fn">bits</a>(self) -&gt; Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Bits" title="type ieee754::Ieee754::Bits">Bits</a></h4></section></summary><div class="docblock"><p>View <code>self</code> as a collection of bits.</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ieee754::Ieee754;
<span class="kw">let </span>x: f32 = <span class="number">1.0</span>;
<span class="macro">assert_eq!</span>(x.bits(), <span class="number">0x3f80_0000</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.from_bits" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#146">source</a><h4 class="code-header">fn <a href="#tymethod.from_bits" class="fn">from_bits</a>(x: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Bits" title="type ieee754::Ieee754::Bits">Bits</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>View a collections of bits as a floating point number.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ieee754::Ieee754;
<span class="kw">let </span>float: f32 = Ieee754::from_bits(<span class="number">0xbf80_0000</span>);
<span class="macro">assert_eq!</span>(float, -<span class="number">1.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.exponent_bias" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#158">source</a><h4 class="code-header">fn <a href="#tymethod.exponent_bias" class="fn">exponent_bias</a>() -&gt; Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Exponent" title="type ieee754::Ieee754::Exponent">Exponent</a></h4></section></summary><div class="docblock"><p>Get the bias of the stored exponent.</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ieee754::Ieee754;

<span class="macro">assert_eq!</span>(f32::exponent_bias(), <span class="number">127</span>);
<span class="macro">assert_eq!</span>(f64::exponent_bias(), <span class="number">1023</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.decompose_raw" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#201">source</a><h4 class="code-header">fn <a href="#tymethod.decompose_raw" class="fn">decompose_raw</a>(self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.bool.html">bool</a>, Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.RawExponent" title="type ieee754::Ieee754::RawExponent">RawExponent</a>, Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Significand" title="type ieee754::Ieee754::Significand">Significand</a>)</h4></section></summary><div class="docblock"><p>Break <code>self</code> into the three constituent parts of an IEEE754 float.</p>
<p>The exponent returned is the raw bits, use <code>exponent_bias</code> to
compute the offset required or use <code>decompose</code> to obtain this
in precomputed form.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">§</a>Examples</h5>
<p>Single precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ieee754::Ieee754;

<span class="macro">assert_eq!</span>(<span class="number">1_f32</span>.decompose_raw(), (<span class="bool-val">false</span>, <span class="number">127</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(<span class="number">1234.567_f32</span>.decompose_raw(), (<span class="bool-val">false</span>, <span class="number">137</span>, <span class="number">0x1a5225</span>));

<span class="macro">assert_eq!</span>((-<span class="number">0.525_f32</span>).decompose_raw(), (<span class="bool-val">true</span>, <span class="number">126</span>, <span class="number">0x66666</span>));

<span class="macro">assert_eq!</span>(std::f32::INFINITY.decompose_raw(), (<span class="bool-val">false</span>, <span class="number">255</span>, <span class="number">0</span>));

<span class="kw">let </span>(sign, expn, signif) = std::f32::NAN.decompose_raw();
<span class="macro">assert_eq!</span>((sign, expn), (<span class="bool-val">false</span>, <span class="number">255</span>));
<span class="macro">assert!</span>(signif != <span class="number">0</span>);</code></pre></div>
<p>Double precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ieee754::Ieee754;

<span class="macro">assert_eq!</span>(<span class="number">1_f64</span>.decompose_raw(), (<span class="bool-val">false</span>, <span class="number">1023</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(<span class="number">1234.567_f64</span>.decompose_raw(), (<span class="bool-val">false</span>, <span class="number">1033</span>, <span class="number">0x34a449ba5e354</span>));

<span class="macro">assert_eq!</span>((-<span class="number">0.525_f64</span>).decompose_raw(), (<span class="bool-val">true</span>, <span class="number">1022</span>, <span class="number">0xcccc_cccc_cccd</span>));

<span class="macro">assert_eq!</span>(std::f64::INFINITY.decompose_raw(), (<span class="bool-val">false</span>, <span class="number">2047</span>, <span class="number">0</span>));

<span class="kw">let </span>(sign, expn, signif) = std::f64::NAN.decompose_raw();
<span class="macro">assert_eq!</span>((sign, expn), (<span class="bool-val">false</span>, <span class="number">2047</span>));
<span class="macro">assert!</span>(signif != <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.recompose_raw" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#247">source</a><h4 class="code-header">fn <a href="#tymethod.recompose_raw" class="fn">recompose_raw</a>(
    sign: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.bool.html">bool</a>,
    expn: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.RawExponent" title="type ieee754::Ieee754::RawExponent">RawExponent</a>,
    signif: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Significand" title="type ieee754::Ieee754::Significand">Significand</a>,
) -&gt; Self</h4></section></summary><div class="docblock"><p>Create a <code>Self</code> out of the three constituent parts of an IEEE754 float.</p>
<p>This returns (-1)<sup><code>sign</code></sup> ×
1.<code>signif</code> × 2<sup><code>expn</code> - bias</sup>, where</p>
<ul>
<li><code>sign</code> is treated as if <code>true</code> == <code>1</code> (meaning <code>true</code> is
negative),</li>
<li>1.<code>signif</code> refers to placing the bits of <code>signif</code>
as the fractional part of a number between 1 and 2, and</li>
<li>bias is the exponent bias for this float (see [<code>exponent_bias</code>]).</li>
</ul>
<p>The exponent should be the raw bits: use <code>exponent_bias</code> to
compute the offset required, or use <code>recompose</code> to feed in an
unbiased exponent.</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">§</a>Examples</h5>
<p>Single precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ieee754::Ieee754;

<span class="macro">assert_eq!</span>(f32::recompose_raw(<span class="bool-val">false</span>, <span class="number">127</span>, <span class="number">0</span>), <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>(f32::recompose_raw(<span class="bool-val">false</span>, <span class="number">137</span>, <span class="number">0x1a5225</span>), <span class="number">1234.567</span>);
<span class="macro">assert_eq!</span>(f32::recompose_raw(<span class="bool-val">true</span>, <span class="number">126</span>, <span class="number">0x66666</span>), -<span class="number">0.525</span>);

<span class="macro">assert_eq!</span>(f32::recompose_raw(<span class="bool-val">false</span>, <span class="number">255</span>, <span class="number">0</span>), std::f32::INFINITY);

<span class="macro">assert!</span>(f32::recompose_raw(<span class="bool-val">false</span>, <span class="number">255</span>, <span class="number">1</span>).is_nan());</code></pre></div>
<p>Double precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ieee754::Ieee754;

<span class="macro">assert_eq!</span>(f64::recompose_raw(<span class="bool-val">false</span>, <span class="number">1023</span>, <span class="number">0</span>), <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>(f64::recompose_raw(<span class="bool-val">false</span>, <span class="number">1033</span>, <span class="number">0x34a449ba5e354</span>), <span class="number">1234.567</span>);
<span class="macro">assert_eq!</span>(f64::recompose_raw(<span class="bool-val">true</span>, <span class="number">1022</span>, <span class="number">0xcccc_cccc_cccd</span>), -<span class="number">0.525</span>);

<span class="macro">assert_eq!</span>(f64::recompose_raw(<span class="bool-val">false</span>, <span class="number">2047</span>, <span class="number">0</span>), std::f64::INFINITY);

<span class="macro">assert!</span>(f64::recompose_raw(<span class="bool-val">false</span>, <span class="number">2047</span>, <span class="number">1</span>).is_nan());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.decompose" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#291">source</a><h4 class="code-header">fn <a href="#tymethod.decompose" class="fn">decompose</a>(self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.bool.html">bool</a>, Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Exponent" title="type ieee754::Ieee754::Exponent">Exponent</a>, Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Significand" title="type ieee754::Ieee754::Significand">Significand</a>)</h4></section></summary><div class="docblock"><p>Break <code>self</code> into the three constituent parts of an IEEE754 float.</p>
<p>The exponent returned is the true exponent, after accounting
for the bias it is stored with. The significand does not
include the implicit highest bit (if it exists), e.g. the
24-bit for single precision.</p>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">§</a>Examples</h5>
<p>Single precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ieee754::Ieee754;

<span class="macro">assert_eq!</span>(<span class="number">1_f32</span>.decompose(), (<span class="bool-val">false</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(<span class="number">1234.567_f32</span>.decompose(), (<span class="bool-val">false</span>, <span class="number">10</span>, <span class="number">0x1a5225</span>));

<span class="macro">assert_eq!</span>((-<span class="number">0.525_f32</span>).decompose(), (<span class="bool-val">true</span>, -<span class="number">1</span>, <span class="number">0x66666</span>));

<span class="macro">assert_eq!</span>(std::f32::INFINITY.decompose(), (<span class="bool-val">false</span>, <span class="number">128</span>, <span class="number">0</span>));

<span class="kw">let </span>(sign, expn, signif) = std::f32::NAN.decompose();
<span class="macro">assert_eq!</span>((sign, expn), (<span class="bool-val">false</span>, <span class="number">128</span>));
<span class="macro">assert!</span>(signif != <span class="number">0</span>);</code></pre></div>
<p>Double precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ieee754::Ieee754;

<span class="macro">assert_eq!</span>(<span class="number">1_f64</span>.decompose(), (<span class="bool-val">false</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(<span class="number">1234.567_f64</span>.decompose(), (<span class="bool-val">false</span>, <span class="number">10</span>, <span class="number">0x34a449ba5e354</span>));

<span class="macro">assert_eq!</span>((-<span class="number">0.525_f64</span>).decompose(), (<span class="bool-val">true</span>, -<span class="number">1</span>, <span class="number">0xcccc_cccc_cccd</span>));

<span class="macro">assert_eq!</span>(std::f64::INFINITY.decompose(), (<span class="bool-val">false</span>, <span class="number">1024</span>, <span class="number">0</span>));

<span class="kw">let </span>(sign, expn, signif) = std::f64::NAN.decompose();
<span class="macro">assert_eq!</span>((sign, expn), (<span class="bool-val">false</span>, <span class="number">1024</span>));
<span class="macro">assert!</span>(signif != <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.recompose" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#342">source</a><h4 class="code-header">fn <a href="#tymethod.recompose" class="fn">recompose</a>(
    sign: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.bool.html">bool</a>,
    expn: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Exponent" title="type ieee754::Ieee754::Exponent">Exponent</a>,
    signif: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Significand" title="type ieee754::Ieee754::Significand">Significand</a>,
) -&gt; Self</h4></section></summary><div class="docblock"><p>Create a <code>Self</code> out of the three constituent parts of an IEEE754 float.</p>
<p>This returns (-1)<sup><code>sign</code></sup> ×
1.<code>signif</code> × 2<sup><code>expn</code></sup>, where</p>
<ul>
<li><code>sign</code> is treated as if <code>true</code> == <code>1</code> (meaning <code>true</code> is
negative), and</li>
<li>1.<code>signif</code> refers to placing the bits of <code>signif</code>
as the fractional part of a number between 1 and 2.</li>
</ul>
<p>The exponent should be the true exponent, not accounting for any
bias. The significand should not include the implicit highest
bit (if it exists), e.g. the 24-th bit for single precision.</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">§</a>Examples</h5>
<p>Single precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ieee754::Ieee754;

<span class="comment">// normal numbers
</span><span class="macro">assert_eq!</span>(f32::recompose(<span class="bool-val">false</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>(f32::recompose(<span class="bool-val">false</span>, <span class="number">10</span>, <span class="number">0x1a5225</span>), <span class="number">1234.567</span>);
<span class="macro">assert_eq!</span>(f32::recompose(<span class="bool-val">true</span>, -<span class="number">1</span>, <span class="number">0x66666</span>), -<span class="number">0.525</span>);

<span class="comment">// infinity
</span><span class="macro">assert_eq!</span>(f32::recompose(<span class="bool-val">false</span>, <span class="number">128</span>, <span class="number">0</span>), std::f32::INFINITY);

<span class="comment">// NaN
</span><span class="macro">assert!</span>(f32::recompose(<span class="bool-val">false</span>, <span class="number">128</span>, <span class="number">1</span>).is_nan());</code></pre></div>
<p>Double precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ieee754::Ieee754;

<span class="comment">// normal numbers
</span><span class="macro">assert_eq!</span>(f64::recompose(<span class="bool-val">false</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>(f64::recompose(<span class="bool-val">false</span>, <span class="number">10</span>, <span class="number">0x34a449ba5e354</span>), <span class="number">1234.567</span>);
<span class="macro">assert_eq!</span>(f64::recompose(<span class="bool-val">true</span>, -<span class="number">1</span>, <span class="number">0xcccc_cccc_cccd</span>), -<span class="number">0.525</span>);

<span class="comment">// infinity
</span><span class="macro">assert_eq!</span>(f64::recompose(<span class="bool-val">false</span>, <span class="number">1024</span>, <span class="number">0</span>), std::f64::INFINITY);

<span class="comment">// NaN
</span><span class="macro">assert!</span>(f64::recompose(<span class="bool-val">false</span>, <span class="number">1024</span>, <span class="number">1</span>).is_nan());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.total_cmp" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#418">source</a><h4 class="code-header">fn <a href="#tymethod.total_cmp" class="fn">total_cmp</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.reference.html">&amp;Self</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class="docblock"><p>Compare <code>x</code> and <code>y</code> using the IEEE-754 <code>totalOrder</code> predicate
(Section 5.10).</p>
<p>This orders NaNs before or after all non-NaN floats, depending
on the sign bit. Using -qNaN to represent a quiet NaN with
negative sign bit and similarly for a signalling NaN (sNaN),
the order is:</p>
<div class="example-wrap"><pre class="language-txt"><code>-qNaN &lt; -sNaN &lt; -∞ &lt; -12.34 &lt; -0.0 &lt; +0.0 &lt; +12.34 &lt; +∞ &lt; +sNaN &lt; +qNaN
</code></pre></div>
<p>(NaNs are ordered according to their payload.)</p>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11">§</a>Examples</h5>
<p>Sorting:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::f32;

<span class="kw">use </span>ieee754::Ieee754;

<span class="kw">let </span><span class="kw-2">mut </span>data = <span class="macro">vec!</span>[<span class="number">0.0</span>, f32::NEG_INFINITY, -<span class="number">1.0</span>, f32::INFINITY,
                    f32::NAN, -<span class="number">0.0</span>, <span class="number">12.34e5</span>, -f32::NAN];
data.sort_by(|a, b| a.total_cmp(b));

<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{:.0?}"</span>, data),
           <span class="string">"[NaN, -inf, -1, -0, 0, 1234000, inf, NaN]"</span>);</code></pre></div>
<p>Single precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::cmp::Ordering;
<span class="kw">use </span>std::f32;

<span class="kw">use </span>ieee754::Ieee754;

<span class="comment">// normal comparison
</span><span class="macro">assert_eq!</span>(<span class="number">0_f32</span>.total_cmp(<span class="kw-2">&amp;</span><span class="number">0_f32</span>), Ordering::Equal);
<span class="macro">assert_eq!</span>(<span class="number">0_f32</span>.total_cmp(<span class="kw-2">&amp;</span><span class="number">1_f32</span>), Ordering::Less);
<span class="macro">assert_eq!</span>(<span class="number">1e10_f32</span>.total_cmp(<span class="kw-2">&amp;</span>f32::NEG_INFINITY), Ordering::Greater);

<span class="comment">// signed zero
</span><span class="macro">assert_eq!</span>(<span class="number">0_f32</span>.total_cmp(<span class="kw-2">&amp;</span>-<span class="number">0_f32</span>), Ordering::Greater);

<span class="comment">// NaNs
</span><span class="macro">assert_eq!</span>(f32::NAN.total_cmp(<span class="kw-2">&amp;</span><span class="number">0_f32</span>), Ordering::Greater);
<span class="macro">assert_eq!</span>(f32::NAN.total_cmp(<span class="kw-2">&amp;</span>f32::INFINITY), Ordering::Greater);
<span class="macro">assert_eq!</span>((-f32::NAN).total_cmp(<span class="kw-2">&amp;</span>f32::NEG_INFINITY), Ordering::Less);</code></pre></div>
<p>Double precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::cmp::Ordering;
<span class="kw">use </span>std::f64;

<span class="kw">use </span>ieee754::Ieee754;

<span class="comment">// normal comparison
</span><span class="macro">assert_eq!</span>(<span class="number">0_f64</span>.total_cmp(<span class="kw-2">&amp;</span><span class="number">0_f64</span>), Ordering::Equal);
<span class="macro">assert_eq!</span>(<span class="number">0_f64</span>.total_cmp(<span class="kw-2">&amp;</span><span class="number">1_f64</span>), Ordering::Less);
<span class="macro">assert_eq!</span>(<span class="number">1e10_f64</span>.total_cmp(<span class="kw-2">&amp;</span>f64::NEG_INFINITY), Ordering::Greater);

<span class="comment">// signed zero
</span><span class="macro">assert_eq!</span>(<span class="number">0_f64</span>.total_cmp(<span class="kw-2">&amp;</span>-<span class="number">0_f64</span>), Ordering::Greater);

<span class="comment">// NaNs
</span><span class="macro">assert_eq!</span>(f64::NAN.total_cmp(<span class="kw-2">&amp;</span><span class="number">0_f64</span>), Ordering::Greater);
<span class="macro">assert_eq!</span>(f64::NAN.total_cmp(<span class="kw-2">&amp;</span>f64::INFINITY), Ordering::Greater);
<span class="macro">assert_eq!</span>((-f64::NAN).total_cmp(<span class="kw-2">&amp;</span>f64::NEG_INFINITY), Ordering::Less);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.abs" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#472">source</a><h4 class="code-header">fn <a href="#tymethod.abs" class="fn">abs</a>(self) -&gt; Self</h4></section></summary><div class="docblock"><p>Return the absolute value of <code>x</code>.</p>
<p>This provides a no_std/core-only version of the built-in <code>abs</code> in
<code>std</code>, until
<a href="https://github.com/rust-lang/rust/issues/50145">#50145</a> is
addressed.</p>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12">§</a>Examples</h5>
<p>Single precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![no_std]
</span><span class="kw">use </span>core::f32;

<span class="kw">use </span>ieee754::Ieee754;

<span class="macro">assert_eq!</span>((<span class="number">0_f32</span>).abs(), <span class="number">0.0</span>);

<span class="macro">assert_eq!</span>((<span class="number">12.34_f32</span>).abs(), <span class="number">12.34</span>);
<span class="macro">assert_eq!</span>((-<span class="number">12.34_f32</span>).abs(), <span class="number">12.34</span>);

<span class="macro">assert_eq!</span>(f32::INFINITY.abs(), f32::INFINITY);
<span class="macro">assert_eq!</span>(f32::NEG_INFINITY.abs(), f32::INFINITY);
<span class="macro">assert!</span>(f32::NAN.abs().is_nan());</code></pre></div>
<p>Double precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![no_std]
</span><span class="kw">use </span>core::f64;

<span class="kw">use </span>ieee754::Ieee754;

<span class="macro">assert_eq!</span>((<span class="number">0_f64</span>).abs(), <span class="number">0.0</span>);

<span class="macro">assert_eq!</span>((<span class="number">12.34_f64</span>).abs(), <span class="number">12.34</span>);
<span class="macro">assert_eq!</span>((-<span class="number">12.34_f64</span>).abs(), <span class="number">12.34</span>);

<span class="macro">assert_eq!</span>(f64::INFINITY.abs(), f64::INFINITY);
<span class="macro">assert_eq!</span>(f64::NEG_INFINITY.abs(), f64::INFINITY);
<span class="macro">assert!</span>(f64::NAN.abs().is_nan());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.copy_sign" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#533">source</a><h4 class="code-header">fn <a href="#tymethod.copy_sign" class="fn">copy_sign</a>(self, sign: Self) -&gt; Self</h4></section></summary><div class="docblock"><p>Return a float with the magnitude of <code>self</code> but the sign of
<code>sign</code>.</p>
<p>If <code>sign</code> is NaN, this still uses its sign bit, and does not
(necessarily) return NaN.</p>
<h5 id="examples-13"><a class="doc-anchor" href="#examples-13">§</a>Examples</h5>
<p>Single precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::f32;

<span class="kw">use </span>ieee754::Ieee754;

<span class="comment">// normal numbers
</span><span class="macro">assert_eq!</span>(<span class="number">1_f32</span>.copy_sign(<span class="number">1.0</span>), <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>(<span class="number">2_f32</span>.copy_sign(-<span class="number">1.0</span>), -<span class="number">2.0</span>);
<span class="macro">assert_eq!</span>((-<span class="number">3_f32</span>).copy_sign(<span class="number">1.0</span>), <span class="number">3.0</span>);
<span class="macro">assert_eq!</span>((-<span class="number">4_f32</span>).copy_sign(-<span class="number">1.0</span>), -<span class="number">4.0</span>);

<span class="comment">// infinities
</span><span class="macro">assert_eq!</span>(<span class="number">5_f32</span>.copy_sign(f32::NEG_INFINITY), -<span class="number">5.0</span>);
<span class="macro">assert_eq!</span>(f32::NEG_INFINITY.copy_sign(<span class="number">1.0</span>), f32::INFINITY);

<span class="comment">// signs of zeros matter
</span><span class="macro">assert_eq!</span>((-<span class="number">6_f32</span>).copy_sign(<span class="number">0.0</span>), <span class="number">6.0</span>);
<span class="macro">assert_eq!</span>(<span class="number">7_f32</span>.copy_sign(-<span class="number">0.0</span>), -<span class="number">7.0</span>);

<span class="comment">// NaNs only propagate on the self argument
</span><span class="macro">assert!</span>(f32::NAN.copy_sign(<span class="number">1.0</span>).is_nan());
<span class="macro">assert_eq!</span>(<span class="number">8_f32</span>.copy_sign(-f32::NAN), -<span class="number">8.0</span>);</code></pre></div>
<p>Double precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::f64;

<span class="kw">use </span>ieee754::Ieee754;

<span class="comment">// normal numbers
</span><span class="macro">assert_eq!</span>(<span class="number">1_f64</span>.copy_sign(<span class="number">1.0</span>), <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>(<span class="number">2_f64</span>.copy_sign(-<span class="number">1.0</span>), -<span class="number">2.0</span>);
<span class="macro">assert_eq!</span>((-<span class="number">3_f64</span>).copy_sign(<span class="number">1.0</span>), <span class="number">3.0</span>);
<span class="macro">assert_eq!</span>((-<span class="number">4_f64</span>).copy_sign(-<span class="number">1.0</span>), -<span class="number">4.0</span>);

<span class="comment">// infinities
</span><span class="macro">assert_eq!</span>(<span class="number">5_f64</span>.copy_sign(f64::NEG_INFINITY), -<span class="number">5.0</span>);
<span class="macro">assert_eq!</span>(f64::NEG_INFINITY.copy_sign(<span class="number">1.0</span>), f64::INFINITY);

<span class="comment">// signs of zeros matter
</span><span class="macro">assert_eq!</span>((-<span class="number">6_f64</span>).copy_sign(<span class="number">0.0</span>), <span class="number">6.0</span>);
<span class="macro">assert_eq!</span>(<span class="number">7_f64</span>.copy_sign(-<span class="number">0.0</span>), -<span class="number">7.0</span>);

<span class="comment">// NaNs only propagate on the self argument
</span><span class="macro">assert!</span>(f64::NAN.copy_sign(<span class="number">1.0</span>).is_nan());
<span class="macro">assert_eq!</span>(<span class="number">8_f64</span>.copy_sign(-f64::NAN), -<span class="number">8.0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.sign" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#596">source</a><h4 class="code-header">fn <a href="#tymethod.sign" class="fn">sign</a>(self) -&gt; Self</h4></section></summary><div class="docblock"><p>Return the sign of <code>x</code>.</p>
<p>This provides a no_std/core-only function similar to the
built-in <code>signum</code> in <code>std</code> (until
<a href="https://github.com/rust-lang/rust/issues/50145">#50145</a> is
addressed). This <code>sign</code> function differs at two values; it
matches the mathematical definitions when <code>self == 0.0</code> :</p>
<div><table><thead><tr><th style="text-align: right"><code>x</code></th><th style="text-align: right"><code>x.signum()</code> (<code>std</code>)</th><th style="text-align: right"><code>x.sign()</code> (<code>ieee754</code>)</th></tr></thead><tbody>
<tr><td style="text-align: right">&lt; 0.0</td><td style="text-align: right">−1.0</td><td style="text-align: right">−1.0</td></tr>
<tr><td style="text-align: right">−0.0</td><td style="text-align: right">−1.0</td><td style="text-align: right"><strong>−0.0</strong></td></tr>
<tr><td style="text-align: right">+0.0</td><td style="text-align: right">+1.0</td><td style="text-align: right"><strong>+0.0</strong></td></tr>
<tr><td style="text-align: right">&gt; 0.0</td><td style="text-align: right">+1.0</td><td style="text-align: right">+1.0</td></tr>
<tr><td style="text-align: right">NaN</td><td style="text-align: right">NaN</td><td style="text-align: right">NaN</td></tr>
</tbody></table>
</div><h5 id="examples-14"><a class="doc-anchor" href="#examples-14">§</a>Examples</h5>
<p>Single precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::f32;
<span class="kw">use </span>std::cmp::Ordering;

<span class="kw">use </span>ieee754::Ieee754;

<span class="comment">// zeros
</span><span class="macro">assert_eq!</span>(<span class="number">0_f32</span>.sign().total_cmp(<span class="kw-2">&amp;</span><span class="number">0.0</span>), Ordering::Equal);
<span class="macro">assert_eq!</span>((-<span class="number">0_f32</span>).sign().total_cmp(<span class="kw-2">&amp;</span>-<span class="number">0.0</span>), Ordering::Equal);

<span class="comment">// normal numbers
</span><span class="macro">assert_eq!</span>((<span class="number">12.34_f32</span>).sign(), <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>((-<span class="number">12.34_f32</span>).sign(), -<span class="number">1.0</span>);

<span class="comment">// extremes
</span><span class="macro">assert_eq!</span>(f32::INFINITY.sign(), <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>(f32::NEG_INFINITY.sign(), -<span class="number">1.0</span>);
<span class="macro">assert!</span>(f32::NAN.sign().is_nan());</code></pre></div>
<p>Double precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::f64;
<span class="kw">use </span>std::cmp::Ordering;

<span class="kw">use </span>ieee754::Ieee754;

<span class="comment">// zeros
</span><span class="macro">assert_eq!</span>(<span class="number">0_f64</span>.sign().total_cmp(<span class="kw-2">&amp;</span><span class="number">0.0</span>), Ordering::Equal);
<span class="macro">assert_eq!</span>((-<span class="number">0_f64</span>).sign().total_cmp(<span class="kw-2">&amp;</span>-<span class="number">0.0</span>), Ordering::Equal);

<span class="comment">// normal numbers
</span><span class="macro">assert_eq!</span>((<span class="number">12.34_f64</span>).sign(), <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>((-<span class="number">12.34_f64</span>).sign(), -<span class="number">1.0</span>);

<span class="comment">// extremes
</span><span class="macro">assert_eq!</span>(f64::INFINITY.sign(), <span class="number">1.0</span>);
<span class="macro">assert_eq!</span>(f64::NEG_INFINITY.sign(), -<span class="number">1.0</span>);
<span class="macro">assert!</span>(f64::NAN.sign().is_nan());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.rel_error" class="method"><a class="src rightside" href="../src/ieee754/traits.rs.html#684">source</a><h4 class="code-header">fn <a href="#tymethod.rel_error" class="fn">rel_error</a>(self, exact: Self) -&gt; Self</h4></section></summary><div class="docblock"><p>Compute the (generalized) <strong>signed</strong> relative error of <code>self</code>
as an approximation to <code>exact</code>.</p>
<p>This computes the signed value: positive indicates <code>self</code> in
the opposite direction to 0 from <code>exact</code>; negative indicates
<code>self</code> is in the same direction as 0 from <code>exact</code>. Use
<code>x.rel_error(exact).abs()</code> to get the non-signed relative
error.</p>
<p>The “generalized” refers to <code>exact</code> being 0 or ±∞ the handling
of which is designed to indicate a “failure” (infinite error),
if <code>self</code> doesn’t precisely equal <code>exact</code>. This behaviour is
designed for checking output of algorithms on floats when it
is often desirable to match 0.0 and ±∞ perfectly.</p>
<p>The values of this function are:</p>
<div><table><thead><tr><th style="text-align: right"><code>exact</code></th><th style="text-align: right"><code>x</code></th><th style="text-align: right"><code>x.rel_error(exact)</code></th></tr></thead><tbody>
<tr><td style="text-align: right">NaN</td><td style="text-align: right">any value</td><td style="text-align: right">NaN</td></tr>
<tr><td style="text-align: right">any value</td><td style="text-align: right">NaN</td><td style="text-align: right">NaN</td></tr>
<tr><td style="text-align: right">0</td><td style="text-align: right">equal to <code>exact</code></td><td style="text-align: right">0</td></tr>
<tr><td style="text-align: right">0</td><td style="text-align: right">not equal to <code>exact</code></td><td style="text-align: right">signum(<code>x</code>) × ∞</td></tr>
<tr><td style="text-align: right">±∞</td><td style="text-align: right">equal to <code>exact</code></td><td style="text-align: right">0</td></tr>
<tr><td style="text-align: right">±∞</td><td style="text-align: right">not equal to <code>exact</code></td><td style="text-align: right">-∞</td></tr>
<tr><td style="text-align: right">any other value</td><td style="text-align: right">any value</td><td style="text-align: right"><code>(x - exact) / exact</code></td></tr>
</tbody></table>
</div>
<p>The sign of a zero-valued argument has no effect on the result
of this function.</p>
<h5 id="examples-15"><a class="doc-anchor" href="#examples-15">§</a>Examples</h5>
<p>Single precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::f32;

<span class="kw">use </span>ieee754::Ieee754;

<span class="macro">assert_eq!</span>(<span class="number">4_f32</span>.rel_error(<span class="number">4.0</span>), <span class="number">0.0</span>);
<span class="macro">assert_eq!</span>(<span class="number">3_f32</span>.rel_error(<span class="number">4.0</span>), -<span class="number">0.25</span>);
<span class="macro">assert_eq!</span>(<span class="number">5_f32</span>.rel_error(<span class="number">4.0</span>), <span class="number">0.25</span>);

<span class="comment">// zero
</span><span class="macro">assert_eq!</span>(<span class="number">0_f32</span>.rel_error(<span class="number">0.0</span>), <span class="number">0.0</span>);
<span class="macro">assert_eq!</span>(<span class="number">1_f32</span>.rel_error(<span class="number">0.0</span>), f32::INFINITY);
<span class="macro">assert_eq!</span>((-<span class="number">1_f32</span>).rel_error(<span class="number">0.0</span>), f32::NEG_INFINITY);

<span class="comment">// infinities
</span><span class="macro">assert_eq!</span>(f32::INFINITY.rel_error(f32::INFINITY), <span class="number">0.0</span>);
<span class="macro">assert_eq!</span>(<span class="number">0_f32</span>.rel_error(f32::INFINITY), f32::NEG_INFINITY);

<span class="macro">assert_eq!</span>(f32::NEG_INFINITY.rel_error(f32::NEG_INFINITY), <span class="number">0.0</span>);
<span class="macro">assert_eq!</span>(<span class="number">0_f32</span>.rel_error(f32::NEG_INFINITY), f32::NEG_INFINITY);

<span class="comment">// NaNs
</span><span class="macro">assert!</span>(f32::NAN.rel_error(<span class="number">4.0</span>).is_nan());
<span class="macro">assert!</span>(<span class="number">4_f32</span>.rel_error(f32::NAN).is_nan());</code></pre></div>
<p>Double precision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::f64;
<span class="kw">use </span>ieee754::Ieee754;

<span class="macro">assert_eq!</span>(<span class="number">4_f64</span>.rel_error(<span class="number">4.0</span>), <span class="number">0.0</span>);
<span class="macro">assert_eq!</span>(<span class="number">3_f64</span>.rel_error(<span class="number">4.0</span>), -<span class="number">0.25</span>);
<span class="macro">assert_eq!</span>(<span class="number">5_f64</span>.rel_error(<span class="number">4.0</span>), <span class="number">0.25</span>);

<span class="comment">// zero
</span><span class="macro">assert_eq!</span>(<span class="number">0_f64</span>.rel_error(<span class="number">0.0</span>), <span class="number">0.0</span>);
<span class="macro">assert_eq!</span>(<span class="number">1_f64</span>.rel_error(<span class="number">0.0</span>), f64::INFINITY);
<span class="macro">assert_eq!</span>((-<span class="number">1_f64</span>).rel_error(<span class="number">0.0</span>), f64::NEG_INFINITY);

<span class="comment">// infinities
</span><span class="macro">assert_eq!</span>(f64::INFINITY.rel_error(f64::INFINITY), <span class="number">0.0</span>);
<span class="macro">assert_eq!</span>(<span class="number">0_f64</span>.rel_error(f64::INFINITY), f64::NEG_INFINITY);

<span class="macro">assert_eq!</span>(f64::NEG_INFINITY.rel_error(f64::NEG_INFINITY), <span class="number">0.0</span>);
<span class="macro">assert_eq!</span>(<span class="number">0_f64</span>.rel_error(f64::NEG_INFINITY), f64::NEG_INFINITY);

<span class="comment">// NaNs
</span><span class="macro">assert!</span>(f64::NAN.rel_error(<span class="number">4.0</span>).is_nan());
<span class="macro">assert!</span>(<span class="number">4_f64</span>.rel_error(f64::NAN).is_nan());</code></pre></div>
</div></details></div><h2 id="object-safety" class="section-header">Object Safety<a href="#object-safety" class="anchor">§</a></h2><div class="object-safety-info">This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.80.1/reference/items/traits.html#object-safety">object safe</a>.</div><h2 id="foreign-impls" class="section-header">Implementations on Foreign Types<a href="#foreign-impls" class="anchor">§</a></h2><details class="toggle implementors-toggle"><summary><section id="impl-Ieee754-for-f32" class="impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#517">source</a><a href="#impl-Ieee754-for-f32" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.Ieee754.html" title="trait ieee754::Ieee754">Ieee754</a> for <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.f32.html">f32</a></h3></section></summary><div class="impl-items"><section id="associatedtype.Bits-1" class="associatedtype trait-impl"><a href="#associatedtype.Bits-1" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Bits" class="associatedtype">Bits</a> = <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.u32.html">u32</a></h4></section><section id="associatedtype.Exponent-1" class="associatedtype trait-impl"><a href="#associatedtype.Exponent-1" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Exponent" class="associatedtype">Exponent</a> = <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.i16.html">i16</a></h4></section><section id="associatedtype.RawExponent-1" class="associatedtype trait-impl"><a href="#associatedtype.RawExponent-1" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.RawExponent" class="associatedtype">RawExponent</a> = <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.u8.html">u8</a></h4></section><section id="associatedtype.Significand-1" class="associatedtype trait-impl"><a href="#associatedtype.Significand-1" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Significand" class="associatedtype">Significand</a> = <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.u32.html">u32</a></h4></section><section id="method.upto" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#517">source</a><a href="#method.upto" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.upto" class="fn">upto</a>(self, lim: Self) -&gt; <a class="struct" href="struct.Iter.html" title="struct ieee754::Iter">Iter</a>&lt;Self&gt; <a href="#" class="tooltip" data-notable-ty="Iter&lt;Self&gt;">ⓘ</a></h4></section><section id="method.ulp" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#517">source</a><a href="#method.ulp" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.ulp" class="fn">ulp</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section><section id="method.next" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#517">source</a><a href="#method.next" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.next" class="fn">next</a>(self) -&gt; Self</h4></section><section id="method.prev" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#517">source</a><a href="#method.prev" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.prev" class="fn">prev</a>(self) -&gt; Self</h4></section><section id="method.exponent_bias" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#517">source</a><a href="#method.exponent_bias" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.exponent_bias" class="fn">exponent_bias</a>() -&gt; Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Exponent" title="type ieee754::Ieee754::Exponent">Exponent</a></h4></section><section id="method.bits" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#517">source</a><a href="#method.bits" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.bits" class="fn">bits</a>(self) -&gt; Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Bits" title="type ieee754::Ieee754::Bits">Bits</a></h4></section><section id="method.from_bits" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#517">source</a><a href="#method.from_bits" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.from_bits" class="fn">from_bits</a>(bits: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Bits" title="type ieee754::Ieee754::Bits">Bits</a>) -&gt; Self</h4></section><section id="method.decompose_raw" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#517">source</a><a href="#method.decompose_raw" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.decompose_raw" class="fn">decompose_raw</a>(self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.bool.html">bool</a>, Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.RawExponent" title="type ieee754::Ieee754::RawExponent">RawExponent</a>, Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Significand" title="type ieee754::Ieee754::Significand">Significand</a>)</h4></section><section id="method.recompose_raw" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#517">source</a><a href="#method.recompose_raw" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.recompose_raw" class="fn">recompose_raw</a>(
    sign: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.bool.html">bool</a>,
    expn: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.RawExponent" title="type ieee754::Ieee754::RawExponent">RawExponent</a>,
    signif: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Significand" title="type ieee754::Ieee754::Significand">Significand</a>,
) -&gt; Self</h4></section><section id="method.decompose" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#517">source</a><a href="#method.decompose" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.decompose" class="fn">decompose</a>(self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.bool.html">bool</a>, Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Exponent" title="type ieee754::Ieee754::Exponent">Exponent</a>, Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Significand" title="type ieee754::Ieee754::Significand">Significand</a>)</h4></section><section id="method.recompose" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#517">source</a><a href="#method.recompose" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.recompose" class="fn">recompose</a>(
    sign: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.bool.html">bool</a>,
    expn: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Exponent" title="type ieee754::Ieee754::Exponent">Exponent</a>,
    signif: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Significand" title="type ieee754::Ieee754::Significand">Significand</a>,
) -&gt; Self</h4></section><section id="method.total_cmp" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#517">source</a><a href="#method.total_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.total_cmp" class="fn">total_cmp</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.reference.html">&amp;Self</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section><section id="method.abs" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#517">source</a><a href="#method.abs" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.abs" class="fn">abs</a>(self) -&gt; Self</h4></section><section id="method.copy_sign" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#517">source</a><a href="#method.copy_sign" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.copy_sign" class="fn">copy_sign</a>(self, sign: Self) -&gt; Self</h4></section><section id="method.sign" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#517">source</a><a href="#method.sign" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.sign" class="fn">sign</a>(self) -&gt; Self</h4></section><section id="method.rel_error" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#517">source</a><a href="#method.rel_error" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.rel_error" class="fn">rel_error</a>(self, exact: Self) -&gt; Self</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Ieee754-for-f64" class="impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#518">source</a><a href="#impl-Ieee754-for-f64" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="trait.Ieee754.html" title="trait ieee754::Ieee754">Ieee754</a> for <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.f64.html">f64</a></h3></section></summary><div class="impl-items"><section id="associatedtype.Bits-2" class="associatedtype trait-impl"><a href="#associatedtype.Bits-2" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Bits" class="associatedtype">Bits</a> = <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.u64.html">u64</a></h4></section><section id="associatedtype.Exponent-2" class="associatedtype trait-impl"><a href="#associatedtype.Exponent-2" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Exponent" class="associatedtype">Exponent</a> = <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.i16.html">i16</a></h4></section><section id="associatedtype.RawExponent-2" class="associatedtype trait-impl"><a href="#associatedtype.RawExponent-2" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.RawExponent" class="associatedtype">RawExponent</a> = <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.u16.html">u16</a></h4></section><section id="associatedtype.Significand-2" class="associatedtype trait-impl"><a href="#associatedtype.Significand-2" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Significand" class="associatedtype">Significand</a> = <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.u64.html">u64</a></h4></section><section id="method.upto-1" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#518">source</a><a href="#method.upto-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.upto" class="fn">upto</a>(self, lim: Self) -&gt; <a class="struct" href="struct.Iter.html" title="struct ieee754::Iter">Iter</a>&lt;Self&gt; <a href="#" class="tooltip" data-notable-ty="Iter&lt;Self&gt;">ⓘ</a></h4></section><section id="method.ulp-1" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#518">source</a><a href="#method.ulp-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.ulp" class="fn">ulp</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section><section id="method.next-1" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#518">source</a><a href="#method.next-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.next" class="fn">next</a>(self) -&gt; Self</h4></section><section id="method.prev-1" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#518">source</a><a href="#method.prev-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.prev" class="fn">prev</a>(self) -&gt; Self</h4></section><section id="method.exponent_bias-1" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#518">source</a><a href="#method.exponent_bias-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.exponent_bias" class="fn">exponent_bias</a>() -&gt; Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Exponent" title="type ieee754::Ieee754::Exponent">Exponent</a></h4></section><section id="method.bits-1" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#518">source</a><a href="#method.bits-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.bits" class="fn">bits</a>(self) -&gt; Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Bits" title="type ieee754::Ieee754::Bits">Bits</a></h4></section><section id="method.from_bits-1" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#518">source</a><a href="#method.from_bits-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.from_bits" class="fn">from_bits</a>(bits: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Bits" title="type ieee754::Ieee754::Bits">Bits</a>) -&gt; Self</h4></section><section id="method.decompose_raw-1" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#518">source</a><a href="#method.decompose_raw-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.decompose_raw" class="fn">decompose_raw</a>(self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.bool.html">bool</a>, Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.RawExponent" title="type ieee754::Ieee754::RawExponent">RawExponent</a>, Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Significand" title="type ieee754::Ieee754::Significand">Significand</a>)</h4></section><section id="method.recompose_raw-1" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#518">source</a><a href="#method.recompose_raw-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.recompose_raw" class="fn">recompose_raw</a>(
    sign: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.bool.html">bool</a>,
    expn: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.RawExponent" title="type ieee754::Ieee754::RawExponent">RawExponent</a>,
    signif: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Significand" title="type ieee754::Ieee754::Significand">Significand</a>,
) -&gt; Self</h4></section><section id="method.decompose-1" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#518">source</a><a href="#method.decompose-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.decompose" class="fn">decompose</a>(self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.bool.html">bool</a>, Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Exponent" title="type ieee754::Ieee754::Exponent">Exponent</a>, Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Significand" title="type ieee754::Ieee754::Significand">Significand</a>)</h4></section><section id="method.recompose-1" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#518">source</a><a href="#method.recompose-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.recompose" class="fn">recompose</a>(
    sign: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.bool.html">bool</a>,
    expn: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Exponent" title="type ieee754::Ieee754::Exponent">Exponent</a>,
    signif: Self::<a class="associatedtype" href="trait.Ieee754.html#associatedtype.Significand" title="type ieee754::Ieee754::Significand">Significand</a>,
) -&gt; Self</h4></section><section id="method.total_cmp-1" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#518">source</a><a href="#method.total_cmp-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.total_cmp" class="fn">total_cmp</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/core/primitive.reference.html">&amp;Self</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section><section id="method.abs-1" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#518">source</a><a href="#method.abs-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.abs" class="fn">abs</a>(self) -&gt; Self</h4></section><section id="method.copy_sign-1" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#518">source</a><a href="#method.copy_sign-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.copy_sign" class="fn">copy_sign</a>(self, sign: Self) -&gt; Self</h4></section><section id="method.sign-1" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#518">source</a><a href="#method.sign-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.sign" class="fn">sign</a>(self) -&gt; Self</h4></section><section id="method.rel_error-1" class="method trait-impl"><a class="src rightside" href="../src/ieee754/impls.rs.html#518">source</a><a href="#method.rel_error-1" class="anchor">§</a><h4 class="code-header">fn <a href="#tymethod.rel_error" class="fn">rel_error</a>(self, exact: Self) -&gt; Self</h4></section></div></details><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"></div><script src="../trait.impl/ieee754/traits/trait.Ieee754.js" data-ignore-extern-crates="core" async></script><script type="text/json" id="notable-traits-data">{"Iter<Self>":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.Iter.html\" title=\"struct ieee754::Iter\">Iter</a>&lt;T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T: <a class=\"trait\" href=\"trait.Ieee754.html\" title=\"trait ieee754::Ieee754\">Ieee754</a>&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.80.1/core/iter/traits/iterator/trait.Iterator.html\" title=\"trait core::iter::traits::iterator::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.Iter.html\" title=\"struct ieee754::Iter\">Iter</a>&lt;T&gt;</div><div class=\"where\">    type <a href=\"https://doc.rust-lang.org/1.80.1/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = T;</div>"}</script></section></div></main></body></html>