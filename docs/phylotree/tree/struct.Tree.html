<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A Phylogenetic tree"><title>Tree in phylotree::tree - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="phylotree" data-themes="" data-resource-suffix="" data-rustdoc-version="1.80.1 (3f5fd8dd4 2024-08-06)" data-channel="1.80.1" data-search-js="search-d52510db62a78183.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../phylotree/index.html">phylotree</a><span class="version">0.1.2</span></h2></div><h2 class="location"><a href="#">Tree</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.add">add</a></li><li><a href="#method.add_child">add_child</a></li><li><a href="#method.cherries">cherries</a></li><li><a href="#method.colless">colless</a></li><li><a href="#method.colless_pda">colless_pda</a></li><li><a href="#method.colless_yule">colless_yule</a></li><li><a href="#method.compare_branch_lengths">compare_branch_lengths</a></li><li><a href="#method.compare_topologies">compare_topologies</a></li><li><a href="#method.compress">compress</a></li><li><a href="#method.diameter">diameter</a></li><li><a href="#method.distance_matrix">distance_matrix</a></li><li><a href="#method.distance_matrix_recursive">distance_matrix_recursive</a></li><li><a href="#method.from_file">from_file</a></li><li><a href="#method.from_newick">from_newick</a></li><li><a href="#method.get">get</a></li><li><a href="#method.get_by_name">get_by_name</a></li><li><a href="#method.get_by_name_mut">get_by_name_mut</a></li><li><a href="#method.get_common_ancestor">get_common_ancestor</a></li><li><a href="#method.get_descendants">get_descendants</a></li><li><a href="#method.get_distance">get_distance</a></li><li><a href="#method.get_leaf_names">get_leaf_names</a></li><li><a href="#method.get_leaves">get_leaves</a></li><li><a href="#method.get_mut">get_mut</a></li><li><a href="#method.get_partitions">get_partitions</a></li><li><a href="#method.get_path_from_root">get_path_from_root</a></li><li><a href="#method.get_root">get_root</a></li><li><a href="#method.get_subtree">get_subtree</a></li><li><a href="#method.get_subtree_leaves">get_subtree_leaves</a></li><li><a href="#method.has_unique_tip_names">has_unique_tip_names</a></li><li><a href="#method.height">height</a></li><li><a href="#method.inorder">inorder</a></li><li><a href="#method.is_binary">is_binary</a></li><li><a href="#method.is_rooted">is_rooted</a></li><li><a href="#method.khuner_felsenstein">khuner_felsenstein</a></li><li><a href="#method.ladderize">ladderize</a></li><li><a href="#method.length">length</a></li><li><a href="#method.levelorder">levelorder</a></li><li><a href="#method.n_leaves">n_leaves</a></li><li><a href="#method.new">new</a></li><li><a href="#method.postorder">postorder</a></li><li><a href="#method.preorder">preorder</a></li><li><a href="#method.print">print</a></li><li><a href="#method.print_debug">print_debug</a></li><li><a href="#method.prune">prune</a></li><li><a href="#method.rescale">rescale</a></li><li><a href="#method.reset_bipartition_cache">reset_bipartition_cache</a></li><li><a href="#method.resolve">resolve</a></li><li><a href="#method.robinson_foulds">robinson_foulds</a></li><li><a href="#method.robinson_foulds_norm">robinson_foulds_norm</a></li><li><a href="#method.sackin">sackin</a></li><li><a href="#method.sackin_pda">sackin_pda</a></li><li><a href="#method.sackin_yule">sackin_yule</a></li><li><a href="#method.search_nodes">search_nodes</a></li><li><a href="#method.size">size</a></li><li><a href="#method.to_file">to_file</a></li><li><a href="#method.to_formatted_newick">to_formatted_newick</a></li><li><a href="#method.to_newick">to_newick</a></li><li><a href="#method.weighted_robinson_foulds">weighted_robinson_foulds</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Tree">Clone</a></li><li><a href="#impl-Debug-for-Tree">Debug</a></li><li><a href="#impl-Default-for-Tree">Default</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Tree">!Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Tree">!RefUnwindSafe</a></li><li><a href="#impl-Sync-for-Tree">!Sync</a></li><li><a href="#impl-Send-for-Tree">Send</a></li><li><a href="#impl-Unpin-for-Tree">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Tree">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-Pointable-for-T">Pointable</a></li><li><a href="#impl-ToOwned-for-T">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li><li><a href="#impl-VZip%3CV%3E-for-T">VZip&lt;V&gt;</a></li></ul></section><h2><a href="index.html">In phylotree::tree</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../index.html">phylotree</a>::<wbr><a href="index.html">tree</a>::<wbr><a class="struct" href="#">Tree</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/phylotree/tree/tree.rs.html#120-124">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct Tree { <span class="comment">/* private fields */</span> }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A Phylogenetic tree</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Tree" class="impl"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#130-402">source</a><a href="#impl-Tree" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a></h3></section></summary><div class="docblock"><p>Base methods to add and get <a href="struct.Node.html" title="struct phylotree::tree::Node"><code>Node</code></a> objects to and from the <a href="struct.Tree.html" title="struct phylotree::tree::Tree"><code>Tree</code></a>.</p>
<hr />
<hr />
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#132-138">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>() -&gt; Self</h4></section></summary><div class="docblock"><p>Create a new empty Tree object</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#145-152">source</a><h4 class="code-header">pub fn <a href="#method.add" class="fn">add</a>(&amp;mut self, node: <a class="struct" href="struct.Node.html" title="struct phylotree::tree::Node">Node</a>) -&gt; <a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a></h4></section></summary><div class="docblock"><p>Add a new node to the tree.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_child" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#178-199">source</a><h4 class="code-header">pub fn <a href="#method.add_child" class="fn">add_child</a>(
    &amp;mut self,
    node: <a class="struct" href="struct.Node.html" title="struct phylotree::tree::Node">Node</a>,
    parent: <a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>,
    edge: <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="type.Edge.html" title="type phylotree::tree::Edge">Edge</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Add a child to one of the tree’s nodes.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::{Tree,Node};

<span class="comment">// Create the tree and add a root node
</span><span class="kw">let </span><span class="kw-2">mut </span>tree = Tree::new();
<span class="kw">let </span>root_id = tree.add(Node::new());

<span class="comment">// Add children to the root
</span><span class="kw">let </span>left = tree.add_child(Node::new(), root_id, <span class="prelude-val">None</span>).unwrap();
<span class="kw">let </span>right = tree.add_child(Node::new(), root_id, <span class="prelude-val">Some</span>(<span class="number">0.1</span>)).unwrap();

<span class="macro">assert_eq!</span>(tree.get(<span class="kw-2">&amp;</span>root_id).unwrap().children.len(), <span class="number">2</span>);

<span class="comment">// The depths of child nodes are derived from the parent node
</span><span class="macro">assert_eq!</span>(tree.get(<span class="kw-2">&amp;</span>left).unwrap().get_depth(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(tree.get(<span class="kw-2">&amp;</span>right).unwrap().get_depth(), <span class="number">1</span>);

<span class="comment">// If an edge length is specified then it is set in both child and parent
</span><span class="macro">assert_eq!</span>(tree.get(<span class="kw-2">&amp;</span>right).unwrap().parent_edge, <span class="prelude-val">Some</span>(<span class="number">0.1</span>));
<span class="macro">assert_eq!</span>(tree.get(<span class="kw-2">&amp;</span>root_id).unwrap().get_child_edge(<span class="kw-2">&amp;</span>right), <span class="prelude-val">Some</span>(<span class="number">0.1</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#202-212">source</a><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>(&amp;self, id: &amp;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;<a class="struct" href="struct.Node.html" title="struct phylotree::tree::Node">Node</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Get a reference to a specific Node of the tree</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#215-225">source</a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fn">get_mut</a>(&amp;mut self, id: &amp;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;mut <a class="struct" href="struct.Node.html" title="struct phylotree::tree::Node">Node</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Get a mutable reference to a specific Node of the tree</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_by_name" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#241-245">source</a><h4 class="code-header">pub fn <a href="#method.get_by_name" class="fn">get_by_name</a>(&amp;self, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.Node.html" title="struct phylotree::tree::Node">Node</a>&gt;</h4></section></summary><div class="docblock"><p>Get a reference to a node in the tree by name.
Note that this does not check for name unicity, if several nodes
match a name this funciton will return the first match in the tree.
If you want to find all nodes matching a name in a given tree,
use <a href="struct.Tree.html#method.search_nodes" title="method phylotree::tree::Tree::search_nodes"><code>Tree::search_nodes</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::{Tree, Node};

<span class="kw">let </span><span class="kw-2">mut </span>tree = Tree::new();
<span class="kw">let </span>root_idx = tree.add(Node::new_named(<span class="string">"root"</span>));
<span class="kw">let </span>child_idx = tree.add_child(Node::new_named(<span class="string">"child"</span>), root_idx, <span class="prelude-val">None</span>).unwrap();

<span class="macro">assert_eq!</span>(tree.get_by_name(<span class="string">"child"</span>), <span class="prelude-val">Some</span>(tree.get(<span class="kw-2">&amp;</span>child_idx).unwrap()));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_by_name_mut" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#248-252">source</a><h4 class="code-header">pub fn <a href="#method.get_by_name_mut" class="fn">get_by_name_mut</a>(&amp;mut self, name: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;mut <a class="struct" href="struct.Node.html" title="struct phylotree::tree::Node">Node</a>&gt;</h4></section></summary><div class="docblock"><p>Get a mutable reference to a node in the tree by name</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.search_nodes" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#270-276">source</a><h4 class="code-header">pub fn <a href="#method.search_nodes" class="fn">search_nodes</a>(self, cond: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.fn.html">fn</a>(_: &amp;<a class="struct" href="struct.Node.html" title="struct phylotree::tree::Node">Node</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>&gt;</h4></section></summary><div class="docblock"><p>Search nodes in the tree with a closure.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::{Tree, Node};

<span class="kw">let </span><span class="kw-2">mut </span>tree = Tree::new();
<span class="kw">let </span>root_idx = tree.add(Node::new_named(<span class="string">"root"</span>));
<span class="kw">let </span><span class="kw-2">mut </span>indices = <span class="macro">vec!</span>[];

<span class="kw">for </span>name <span class="kw">in </span>[<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>] {
    <span class="kw">let </span>idx = tree.add_child(Node::new_named(name), root_idx, <span class="prelude-val">None</span>).unwrap();
    <span class="kw">if </span>name == <span class="string">"A" </span>{ indices.push(idx) }
}

<span class="kw">let </span>found = tree.search_nodes(|node| node.name == <span class="prelude-val">Some</span>(<span class="string">"A"</span>.into()));
<span class="macro">assert_eq!</span>(found, indices);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_root" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#280-287">source</a><h4 class="code-header">pub fn <a href="#method.get_root" class="fn">get_root</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Gets the root node. In the case of unrooted trees this node is a “virtual root”
that has exactly 3 children.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_leaves" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#300-306">source</a><h4 class="code-header">pub fn <a href="#method.get_leaves" class="fn">get_leaves</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a <a href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>Vec</code></a> containing the Node IDs of leaf nodes of the tree</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::{Tree, Node};

<span class="kw">let </span><span class="kw-2">mut </span>tree = Tree::new();
<span class="kw">let </span>root_idx = tree.add(Node::new());
<span class="kw">let </span>left = tree.add_child(Node::new(), root_idx, <span class="prelude-val">None</span>).unwrap();
<span class="kw">let </span>right = tree.add_child(Node::new(), root_idx, <span class="prelude-val">None</span>).unwrap();

<span class="macro">assert_eq!</span>(tree.get_leaves(), <span class="macro">vec!</span>[left, right]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_leaf_names" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#323-328">source</a><h4 class="code-header">pub fn <a href="#method.get_leaf_names" class="fn">get_leaf_names</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a <a href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>Vec</code></a> containing the Names of the leaf nodes of the tree</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::{Tree, Node};

<span class="kw">let </span><span class="kw-2">mut </span>tree = Tree::new();
<span class="kw">let </span>root_idx = tree.add(Node::new());
<span class="kw">let _ </span>= tree.add_child(Node::new_named(<span class="string">"left"</span>), root_idx, <span class="prelude-val">None</span>).unwrap();
<span class="kw">let _ </span>= tree.add_child(Node::new_named(<span class="string">"right"</span>), root_idx, <span class="prelude-val">None</span>).unwrap();

<span class="kw">let </span>names: Vec&lt;<span class="kw">_</span>&gt; = tree.get_leaf_names()
    .into_iter()
    .flatten()
    .collect();
<span class="macro">assert_eq!</span>(names, <span class="macro">vec!</span>[<span class="string">"left"</span>, <span class="string">"right"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_subtree" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#345-353">source</a><h4 class="code-header">pub fn <a href="#method.get_subtree" class="fn">get_subtree</a>(&amp;self, root: &amp;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>&gt;, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Gets the node ids of all the nodes in the subtree rooted at the specified node</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>tree = Tree::from_newick(<span class="string">"(A:0.1,B:0.2,(C:0.3,D:0.4)E:0.5)F;"</span>).unwrap();
<span class="kw">let </span>sub_root = tree.get_by_name(<span class="string">"E"</span>).unwrap();
<span class="kw">let </span>subtree: Vec&lt;<span class="kw">_</span>&gt; = tree.get_subtree(<span class="kw-2">&amp;</span>sub_root.id)
    .unwrap()
    .iter()
    .map(|id| tree.get(id).unwrap().name.clone())
    .flatten()
    .collect();

<span class="macro">assert_eq!</span>(subtree, <span class="macro">vec!</span>[<span class="string">"E"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>])</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_descendants" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#370-378">source</a><h4 class="code-header">pub fn <a href="#method.get_descendants" class="fn">get_descendants</a>(&amp;self, root: &amp;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>&gt;, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Gets the node ids of all the nodes in the subtree rooted at the specified node, except the root</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>tree = Tree::from_newick(<span class="string">"(A:0.1,B:0.2,(C:0.3,D:0.4)E:0.5)F;"</span>).unwrap();
<span class="kw">let </span>sub_root = tree.get_by_name(<span class="string">"E"</span>).unwrap();
<span class="kw">let </span>subtree: Vec&lt;<span class="kw">_</span>&gt; = tree.get_descendants(<span class="kw-2">&amp;</span>sub_root.id)
    .unwrap()
    .iter()
    .map(|id| tree.get(id).unwrap().name.clone())
    .flatten()
    .collect();

<span class="macro">assert_eq!</span>(subtree, <span class="macro">vec!</span>[<span class="string">"C"</span>, <span class="string">"D"</span>])</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_subtree_leaves" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#395-401">source</a><h4 class="code-header">pub fn <a href="#method.get_subtree_leaves" class="fn">get_subtree_leaves</a>(
    &amp;self,
    root: &amp;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>&gt;, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Gets the node ids of all the leaves in the subtree rooted at the specified node</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>tree = Tree::from_newick(<span class="string">"(A:0.1,B:0.2,(C:0.3,D:0.4)E:0.5)F;"</span>).unwrap();
<span class="kw">let </span>sub_root = tree.get_by_name(<span class="string">"E"</span>).unwrap();
<span class="kw">let </span>sub_leaves: Vec&lt;<span class="kw">_</span>&gt; = tree.get_subtree_leaves(<span class="kw-2">&amp;</span>sub_root.id)
    .unwrap()
    .iter()
    .map(|id| tree.get(id).unwrap().name.clone())
    .flatten()
    .collect();

<span class="macro">assert_eq!</span>(sub_leaves, <span class="macro">vec!</span>[<span class="string">"C"</span>, <span class="string">"D"</span>])</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Tree-1" class="impl"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#408-535">source</a><a href="#impl-Tree-1" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a></h3></section></summary><div class="docblock"><p>Methods to traverse the <a href="struct.Tree.html" title="struct phylotree::tree::Tree"><code>Tree</code></a></p>
<hr />
<hr />
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.preorder" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#428-435">source</a><h4 class="code-header">pub fn <a href="#method.preorder" class="fn">preorder</a>(&amp;self, root: &amp;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>&gt;, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a vector containing node ids in the same order as the
<a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR">preorder</a> tree traversal</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>tree = Tree::from_newick(<span class="string">"((A,(C,E)D)B,((H)I)G)F;"</span>).unwrap();
<span class="kw">let </span>preorder: Vec&lt;<span class="kw">_</span>&gt; = tree.preorder(<span class="kw-2">&amp;</span>tree.get_root().unwrap())
    .unwrap()
    .iter()
    .map(|id| tree.get(id).unwrap().name.clone())
    .flatten()
    .collect();

<span class="macro">assert_eq!</span>(preorder, <span class="macro">vec!</span>[<span class="string">"F"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>, <span class="string">"D"</span>, <span class="string">"C"</span>, <span class="string">"E"</span>, <span class="string">"G"</span>, <span class="string">"I"</span>, <span class="string">"H"</span>])</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.postorder" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#452-460">source</a><h4 class="code-header">pub fn <a href="#method.postorder" class="fn">postorder</a>(&amp;self, root: &amp;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>&gt;, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a vector containing node ids in the same order as the
<a href="https://en.wikipedia.org/wiki/Tree_traversal#Post-order,_LRN">postorder</a> tree traversal</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>tree = Tree::from_newick(<span class="string">"((A,(C,E)D)B,((H)I)G)F;"</span>).unwrap();
<span class="kw">let </span>postorder: Vec&lt;<span class="kw">_</span>&gt; = tree.postorder(<span class="kw-2">&amp;</span>tree.get_root().unwrap())
    .unwrap()
    .iter()
    .map(|id| tree.get(id).unwrap().name.clone())
    .flatten()
    .collect();

<span class="macro">assert_eq!</span>(postorder, <span class="macro">vec!</span>[<span class="string">"A"</span>, <span class="string">"C"</span>, <span class="string">"E"</span>, <span class="string">"D"</span>, <span class="string">"B"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"G"</span>, <span class="string">"F"</span>])</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.inorder" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#482-504">source</a><h4 class="code-header">pub fn <a href="#method.inorder" class="fn">inorder</a>(&amp;self, root: &amp;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>&gt;, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a vector containing node ids in the same order as the
<a href="https://en.wikipedia.org/wiki/Tree_traversal#In-order,_LNR">inorder</a> tree traversal.
This assumes that the tree is binary.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>tree = Tree::from_newick(<span class="string">"((A,(C,E)D)B,((H)I)G)F;"</span>).unwrap();
<span class="kw">let </span>inorder: Vec&lt;<span class="kw">_</span>&gt; = tree.inorder(<span class="kw-2">&amp;</span>tree.get_root().unwrap())
    .unwrap()
    .iter()
    .map(|id| tree.get(id).unwrap().name.clone())
    .flatten()
    .collect();

<span class="macro">assert_eq!</span>(inorder, <span class="macro">vec!</span>[<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"G"</span>])</code></pre></div>
<p><em>N.B.: the resulting traversal in the example is different than the one in the
<a href="https://en.wikipedia.org/wiki/Tree_traversal">wikipedia</a> page. That is because
the <a href="struct.Node.html" title="struct phylotree::tree::Node"><code>Node</code></a> struct cannot have a right child only, so in our tree I is the left
child of G.</em></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.levelorder" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#521-534">source</a><h4 class="code-header">pub fn <a href="#method.levelorder" class="fn">levelorder</a>(&amp;self, root: &amp;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>&gt;, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns a vector containing node ids in the same order as the
<a href="https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search">levelorder</a> tree traversal</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>tree = Tree::from_newick(<span class="string">"((A,(C,E)D)B,((H)I)G)F;"</span>).unwrap();
<span class="kw">let </span>levelorder: Vec&lt;<span class="kw">_</span>&gt; = tree.levelorder(<span class="kw-2">&amp;</span>tree.get_root().unwrap())
    .unwrap()
    .iter()
    .map(|id| tree.get(id).unwrap().name.clone())
    .flatten()
    .collect();

<span class="macro">assert_eq!</span>(levelorder, <span class="macro">vec!</span>[<span class="string">"F"</span>, <span class="string">"B"</span>, <span class="string">"G"</span>, <span class="string">"A"</span>, <span class="string">"D"</span>, <span class="string">"I"</span>, <span class="string">"C"</span>, <span class="string">"E"</span>, <span class="string">"H"</span>])</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Tree-2" class="impl"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#541-802">source</a><a href="#impl-Tree-2" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a></h3></section></summary><div class="docblock"><p>Methods that compute characteristics and measures to describe the <a href="struct.Tree.html" title="struct phylotree::tree::Tree"><code>Tree</code></a></p>
<hr />
<hr />
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_binary" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#547-562">source</a><h4 class="code-header">pub fn <a href="#method.is_binary" class="fn">is_binary</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Check if the tree is Binary</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_rooted" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#565-569">source</a><h4 class="code-header">pub fn <a href="#method.is_rooted" class="fn">is_rooted</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Checks if the tree is rooted (i.e. the root node exists and has exactly 2 children)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.has_unique_tip_names" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#572-583">source</a><h4 class="code-header">pub fn <a href="#method.has_unique_tip_names" class="fn">has_unique_tip_names</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Checks if all the tips have unique names (This check assumes that all tips have a name)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.size" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#586-588">source</a><h4 class="code-header">pub fn <a href="#method.size" class="fn">size</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of nodes in the tree</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.n_leaves" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#591-593">source</a><h4 class="code-header">pub fn <a href="#method.n_leaves" class="fn">n_leaves</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of leaves in the tree</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.height" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#606-624">source</a><h4 class="code-header">pub fn <a href="#method.height" class="fn">height</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="type" href="type.Edge.html" title="type phylotree::tree::Edge">Edge</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the height of the tree
(i.e. the number of edges or branch length sum from the root to the deepest tip)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>tree = Tree::from_newick(<span class="string">"((A:0.1,B:0.2)G:0.1,(C:0.3,D:0.4)E:0.5)F;"</span>).unwrap();
<span class="macro">assert_eq!</span>(tree.height().unwrap(), <span class="number">0.9</span>);

<span class="kw">let </span>tree_no_brlen = Tree::from_newick(<span class="string">"((A,B)G,(C,D)E)F;"</span>).unwrap();
<span class="macro">assert_eq!</span>(tree_no_brlen.height().unwrap(), <span class="number">2.</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.diameter" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#637-650">source</a><h4 class="code-header">pub fn <a href="#method.diameter" class="fn">diameter</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="type" href="type.Edge.html" title="type phylotree::tree::Edge">Edge</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the diameter of the tree
(i.e. longest tip to tip distance)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>tree = Tree::from_newick(<span class="string">"(A:0.1,B:0.2,(C:0.3,D:0.4)E:0.5)F;"</span>).unwrap();
<span class="macro">assert_eq!</span>(tree.diameter().unwrap(), <span class="number">1.1</span>);

<span class="kw">let </span>tree_no_brlen = Tree::from_newick(<span class="string">"(A,B,(C,D)E)F;"</span>).unwrap();
<span class="macro">assert_eq!</span>(tree_no_brlen.diameter().unwrap(), <span class="number">3.</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.length" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#660-671">source</a><h4 class="code-header">pub fn <a href="#method.length" class="fn">length</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="type" href="type.Edge.html" title="type phylotree::tree::Edge">Edge</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the lenght of the trees
(i.e. the sum of branch lenghts)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>tree = Tree::from_newick(<span class="string">"(A:0.1,B:0.2,(C:0.3,D:0.4)E:0.5)F;"</span>).unwrap();
<span class="macro">assert_eq!</span>(tree.length().unwrap(), <span class="number">1.5</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.cherries" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#685-703">source</a><h4 class="code-header">pub fn <a href="#method.cherries" class="fn">cherries</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Computes the number of cherries in a tree</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.colless" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#714-731">source</a><h4 class="code-header">pub fn <a href="#method.colless" class="fn">colless</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Computes the Colless index for the tree.
The colless index, $I_c$, measures the imbalance of a phylogenetic tree:<br />
$$
I_c = \sum_{i \in nodes} |L_i - R_i|
$$</p>
<p>Where $L_i$ is the number of leaves in the left subtree of node $i$ and
$R_i$ the number of leaves in the right subtree of $i$.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.colless_yule" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#741-748">source</a><h4 class="code-header">pub fn <a href="#method.colless_yule" class="fn">colless_yule</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.f64.html">f64</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Computes the normalized colless statistic with a Yule null model:<br />
$$
I_{yule} = \frac{I_c - n\cdot\log(n) - n(\gamma-1-\log(2))}{n}
$$
Where $I_c$ is the unnormalized colless index <em>(computed with <a href="struct.Tree.html#method.colless" title="method phylotree::tree::Tree::colless"><code>Tree::colless()</code></a>)</em>,
$n$ the number of leaves
and $\gamma$ the <a href="https://en.wikipedia.org/wiki/Euler%27s_constant">Euler constant</a>.<br />
<em>(<a href="https://search.r-project.org/CRAN/refmans/apTreeshape/html/colless.html">see also apTreeshape</a>)</em></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.colless_pda" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#757-760">source</a><h4 class="code-header">pub fn <a href="#method.colless_pda" class="fn">colless_pda</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.f64.html">f64</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Computes the normalized colless statistic with a PDA null model:<br />
$$
I_{PDA} = \frac{I_c}{n^{3/2}}
$$
Where $I_c$ is the unnormalized colless index <em>(computed with <a href="struct.Tree.html#method.colless" title="method phylotree::tree::Tree::colless"><code>Tree::colless()</code></a>)</em>
and $n$ the number of leaves.<br />
<em>(<a href="https://search.r-project.org/CRAN/refmans/apTreeshape/html/colless.html">see also apTreeshape</a>)</em></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sackin" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#765-773">source</a><h4 class="code-header">pub fn <a href="#method.sackin" class="fn">sackin</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Computes the Sackin index. The Sackin index, $I_s$, is computed by taking the
sum over all internal nodes of the number of leaves descending from that node.
A smaller Sackin index means a more balanced tree.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sackin_yule" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#782-789">source</a><h4 class="code-header">pub fn <a href="#method.sackin_yule" class="fn">sackin_yule</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.f64.html">f64</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Computes the normalized Sackin index with a Yule null model:
$$
I_{yule} = \frac{I_s - 2n\cdot \sum_{j=2}^n \frac{1}{j}}{n}
$$
With $I_s$ the unnormalized Sackin index <em>(computed with <a href="struct.Tree.html#method.sackin" title="method phylotree::tree::Tree::sackin"><code>Tree::sackin()</code></a>)</em>
and $n$ the number of leaves in the tree.<br />
<em>(<a href="https://search.r-project.org/CRAN/refmans/apTreeshape/html/sackin.html">see also apTreeshape</a>)</em></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.sackin_pda" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#798-801">source</a><h4 class="code-header">pub fn <a href="#method.sackin_pda" class="fn">sackin_pda</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.f64.html">f64</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Computes the normalized sackin statistic with a PDA null model:
$$
I_{PDA} = \frac{I_s}{n^{3/2}}
$$
With $I_s$ the unnormalized Sackin index <em>(computed with <a href="struct.Tree.html#method.sackin" title="method phylotree::tree::Tree::sackin"><code>Tree::sackin()</code></a>)</em>
and $n$ the number of leaves in the tree.<br />
<em>(<a href="https://search.r-project.org/CRAN/refmans/apTreeshape/html/sackin.html">see also apTreeshape</a>)</em></p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Tree-3" class="impl"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#808-1299">source</a><a href="#impl-Tree-3" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a></h3></section></summary><div class="docblock"><p>Methods that compute edge bipartitions and compare <a href="struct.Tree.html" title="struct phylotree::tree::Tree"><code>Tree</code></a> objects with each other.</p>
<hr />
<hr />
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.get_partitions" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#909-921">source</a><h4 class="code-header">pub fn <a href="#method.get_partitions" class="fn">get_partitions</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.80.1/std/collections/hash/set/struct.HashSet.html" title="struct std::collections::hash::set::HashSet">HashSet</a>&lt;<a class="struct" href="../../fixedbitset/struct.FixedBitSet.html" title="struct fixedbitset::FixedBitSet">FixedBitSet</a>&gt;, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Get all partitions of a tree</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reset_bipartition_cache" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#955-958">source</a><h4 class="code-header">pub fn <a href="#method.reset_bipartition_cache" class="fn">reset_bipartition_cache</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Resets the caches used when computing bipartitions
<em>(i.e. with <a href="struct.Tree.html#method.compare_topologies" title="method phylotree::tree::Tree::compare_topologies"><code>Tree::compare_topologies()</code></a>)</em>.
You should call this if you have computed bipartitions in the tree
and then changed the tree.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.robinson_foulds" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#972-1000">source</a><h4 class="code-header">pub fn <a href="#method.robinson_foulds" class="fn">robinson_foulds</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;Self</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Computes the <a href="https://en.wikipedia.org/wiki/Robinson%E2%80%93Foulds_metric">Robinson Foulds distance</a>
<a href="https://doi.org/10.1016/0025-5564(81)90043-2">(Robinson &amp; Foulds, 1981)</a>
between two trees. The RF distance is defined as the number of unique bipartitions for each tree:
$$
RF = |A\cup B| - |A\cap B|
$$
Where $A$ and $B$ are the sets of bipartitions of the first and second trees.<br />
See also <a href="struct.Tree.html#method.compare_topologies" title="method phylotree::tree::Tree::compare_topologies">Tree::compare_topologies()</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.robinson_foulds_norm" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1012-1021">source</a><h4 class="code-header">pub fn <a href="#method.robinson_foulds_norm" class="fn">robinson_foulds_norm</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;Self</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.f64.html">f64</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Computes the normalized Robinson Foulds distance between two trees
<a href="https://doi.org/10.1016/0025-5564(81)90043-2">(Robinson &amp; Foulds, 1981)</a>.
The RF distance is normalized by the maximum possible RF distance for both trees
<em>(i.e the number of bipartitions in both trees)</em> so that the resulting distance
is contained within [0, 1]:<br />
$$
RF_{norm} = \frac{RF}{|A| + |B|}
$$
Where $A$ and $B$ are the sets of bipartitions of the first and second trees.<br />
See also <a href="struct.Tree.html#method.compare_topologies" title="method phylotree::tree::Tree::compare_topologies">Tree::compare_topologies()</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.weighted_robinson_foulds" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1035-1056">source</a><h4 class="code-header">pub fn <a href="#method.weighted_robinson_foulds" class="fn">weighted_robinson_foulds</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;Self</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.f64.html">f64</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Computes the weighted Robinson Foulds distance between two trees
<a href="https://doi.org/10.1007/BFb0102690">(Robinson &amp; Foulds, 1979)</a>.
This distance is equal to the absolute difference of branch lengths for
matched bipartitions between the two trees, plus branch lenghts for unique bipartitions:<br />
$$
RF_{weighted} = \sum_{e \in A\cap B} |d_{(e,A)} - d_{(e,B)}| +
\sum_{e \in A\setminus B}d_{(e,A)} +
\sum_{e \in B\setminus A}d_{(e,B)}
$$
Where $A$ and $B$ are the sets of bipartitions of the first and second trees,
and $d_{(e,A)}$ the branch length of bipartition $e$ in the first tree ($A$).<br />
See also <a href="struct.Tree.html#method.compare_topologies" title="method phylotree::tree::Tree::compare_topologies">Tree::compare_topologies()</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.khuner_felsenstein" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1071-1092">source</a><h4 class="code-header">pub fn <a href="#method.khuner_felsenstein" class="fn">khuner_felsenstein</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;Self</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.f64.html">f64</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Computes the khuner felsenstein branch score between two trees,
<a href="https://doi.org/10.1093/oxfordjournals.molbev.a040126">(Khuner &amp; Felsenstein, 1994)</a>.
The distance is computed by taking the squared difference of branch lengths for
matched bipartitions between the two trees, plus squared branch lenghts for unique bipartitions.
The branch score is then derived by taking the square root of that total sum:<br />
$$
KF = \sqrt{
\sum_{e \in A\cap B} (d_{(e,A)} - d_{(e,B)})^2 +
\sum_{e \in A\setminus B}d_{(e,A)}^2 +
\sum_{e \in B\setminus A}d_{(e,B)}^2
}
$$
See also <a href="struct.Tree.html#method.compare_topologies" title="method phylotree::tree::Tree::compare_topologies">Tree::compare_topologies()</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.compare_topologies" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1115-1165">source</a><h4 class="code-header">pub fn <a href="#method.compare_topologies" class="fn">compare_topologies</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;Self</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.Comparison.html" title="struct phylotree::tree::Comparison">Comparison</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Compute several the RF metric, the weighted and normalized RF metrics and
the KF branch score in one pass. This is more efficient than calling the
different functions separately.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>tree1 = Tree::from_newick(<span class="string">"(A:0.1,B:0.2,(C:0.3,D:0.4)E:0.5)F;"</span>).unwrap();
<span class="kw">let </span>tree2 = Tree::from_newick(<span class="string">"(A:0.1,D:0.2,(C:0.3,B:0.4)E:0.5)F;"</span>).unwrap();

<span class="kw">let </span>rf = tree1.robinson_foulds(<span class="kw-2">&amp;</span>tree2).unwrap() <span class="kw">as </span>f64;
<span class="kw">let </span>norm_rf = tree1.robinson_foulds_norm(<span class="kw-2">&amp;</span>tree2).unwrap();
<span class="kw">let </span>weighted_rf = tree1.weighted_robinson_foulds(<span class="kw-2">&amp;</span>tree2).unwrap();
<span class="kw">let </span>branch_score = tree1.khuner_felsenstein(<span class="kw-2">&amp;</span>tree2).unwrap();

<span class="kw">let </span>comparison = tree1.compare_topologies(<span class="kw-2">&amp;</span>tree2).unwrap();

<span class="macro">assert_eq!</span>(rf, comparison.rf);
<span class="macro">assert_eq!</span>(norm_rf, comparison.norm_rf);
<span class="macro">assert_eq!</span>(weighted_rf, comparison.weighted_rf);
<span class="macro">assert_eq!</span>(branch_score, comparison.branch_score);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.compare_branch_lengths" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1237-1286">source</a><h4 class="code-header">pub fn <a href="#method.compare_branch_lengths" class="fn">compare_branch_lengths</a>(
    &amp;self,
    other: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;Self</a>,
    include_tips: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.bool.html">bool</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(<a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="type.Edge.html" title="type phylotree::tree::Edge">Edge</a>&gt;, <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="type.Edge.html" title="type phylotree::tree::Edge">Edge</a>&gt;, <a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;(<a class="type" href="type.Edge.html" title="type phylotree::tree::Edge">Edge</a>, <a class="type" href="type.Edge.html" title="type phylotree::tree::Edge">Edge</a>)&gt;), <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Compare sets of branches between 2 trees. This will return 3
sets of branch lengths:</p>
<ul>
<li>branches exclusive to the <code>self</code> tree</li>
<li>branches exclusive to the <code>other</code> tree</li>
<li>2-uples for common branches: (self_len, other_len)</li>
</ul>
<p>You can specify wether to include terminal branches in this calculation or not
with the <code>include_terminal</code> parameter.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="comment">// Ref Tree:     
//               0.3
//         0.2 +----- A
//   0.1 +-----| 0.4      
// +-----|     +----- B
// |     | 0.5            
// |     +----- C      
// |       0.7            
// | 0.6 +----- D      
// +-----| 0.8            
//       +----- E       

// Compared Tree:
//               0.3
//         0.2 +----- A
//   0.1 +-----| 0.4     
// +-----|     +----- C
// |     | 0.5            
// |     +----- B      
// |       7.0            
// | 0.6 +----- D      
// +-----| 0.8            
//       +----- E
//
// We just switched the B and C labels, so we should have 1
// exlusive branch per tree. The compared tree also has one branch
// that is 7.0 instead of 0.7.

</span><span class="kw">let </span>reftree = Tree::from_newick(<span class="string">"(((A:0.3,B:0.4):0.2,C:0.5):0.1,(D:0.7,E:0.8):0.6);"</span>).unwrap();
<span class="kw">let </span>cmptree = Tree::from_newick(<span class="string">"(((A:0.3,C:0.4):0.2,B:0.5):0.1,(D:7.0,E:0.8):0.6);"</span>).unwrap();
 
<span class="comment">// Get branch comparison including terminal branches
</span><span class="kw">let </span>(refset, cmpset, common) = reftree.compare_branch_lengths(<span class="kw-2">&amp;</span>cmptree, <span class="bool-val">true</span>).unwrap();

<span class="macro">assert_eq!</span>(refset, <span class="macro">vec!</span>[<span class="number">0.2</span>]); <span class="comment">// AB,CDE exclusive to reftree
</span><span class="macro">assert_eq!</span>(cmpset, <span class="macro">vec!</span>[<span class="number">0.2</span>]); <span class="comment">// AC,BDE exclusive to cmptree

</span><span class="kw">let </span>expected_common = [
   (<span class="number">0.3</span>, <span class="number">0.3</span>), <span class="comment">// A,...
   </span>(<span class="number">0.4</span>, <span class="number">0.4</span>), <span class="comment">// B,...
   </span>(<span class="number">0.5</span>, <span class="number">0.5</span>), <span class="comment">// C,...
   </span>(<span class="number">0.7</span>, <span class="number">0.7</span>), <span class="comment">// ABC,DE
   </span>(<span class="number">0.7</span>, <span class="number">7.0</span>), <span class="comment">// D,...
   </span>(<span class="number">0.8</span>, <span class="number">0.8</span>), <span class="comment">// E,...
</span>];

<span class="macro">assert_eq!</span>(expected_common.len(), common.len());
<span class="kw">for </span>val <span class="kw">in </span>common {
   <span class="kw">let </span><span class="kw-2">mut </span>found = <span class="bool-val">false</span>;
   <span class="kw">for </span>exp <span class="kw">in </span>expected_common.iter() {
       <span class="kw">if </span>val.<span class="number">0 </span>- exp.<span class="number">0 </span>&lt; f64::EPSILON &amp;&amp; val.<span class="number">1 </span>- exp.<span class="number">1 </span>&lt; f64::EPSILON {
           found = <span class="bool-val">true</span>;
       }
   }
   <span class="macro">assert!</span>(found);
}</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Tree-4" class="impl"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1305-1628">source</a><a href="#impl-Tree-4" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a></h3></section></summary><div class="docblock"><p>Methods to find paths in a <a href="struct.Tree.html" title="struct phylotree::tree::Tree"><code>Tree</code></a> as well as measure distances between <a href="struct.Node.html" title="struct phylotree::tree::Node"><code>Node</code></a> objects.</p>
<hr />
<hr />
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.get_path_from_root" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1324-1336">source</a><h4 class="code-header">pub fn <a href="#method.get_path_from_root" class="fn">get_path_from_root</a>(
    &amp;self,
    node: &amp;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>&gt;, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the path from the node to the root</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>tree = Tree::from_newick(<span class="string">"((A,(C,E)D)B,((H)I)G)F;"</span>).unwrap();
<span class="kw">let </span>path: Vec&lt;<span class="kw">_</span>&gt; = tree.get_path_from_root(<span class="kw-2">&amp;</span><span class="number">5</span>)
    .unwrap()
    .iter()
    .map(|id| tree.get(id).unwrap().name.clone())
    .flatten()
    .collect();

<span class="macro">assert_eq!</span>(path, <span class="macro">vec!</span>[<span class="string">"F"</span>, <span class="string">"B"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>])</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_common_ancestor" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1350-1372">source</a><h4 class="code-header">pub fn <a href="#method.get_common_ancestor" class="fn">get_common_ancestor</a>(
    &amp;self,
    source: &amp;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>,
    target: &amp;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Gets the most recent common ancestor between two tree nodes</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>tree = Tree::from_newick(<span class="string">"((A,(C,E)D)B,((H)I)G)F;"</span>).unwrap();
<span class="kw">let </span>ancestor = tree.get_common_ancestor(
    <span class="kw-2">&amp;</span>tree.get_by_name(<span class="string">"A"</span>).unwrap().id,
    <span class="kw-2">&amp;</span>tree.get_by_name(<span class="string">"D"</span>).unwrap().id,
).unwrap();

<span class="macro">assert_eq!</span>(tree.get(<span class="kw-2">&amp;</span>ancestor).unwrap().name, <span class="prelude-val">Some</span>(<span class="string">"B"</span>.to_owned()))</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_distance" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1388-1430">source</a><h4 class="code-header">pub fn <a href="#method.get_distance" class="fn">get_distance</a>(
    &amp;self,
    source: &amp;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>,
    target: &amp;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;(<a class="enum" href="https://doc.rust-lang.org/1.80.1/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.f64.html">f64</a>&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a>), <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Gets the distance between 2 nodes, returns the sum of branch lengths (if all
branches in the path have lengths) and the number of edges in the path.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>tree = Tree::from_newick(<span class="string">"((A,(C,E)D)B,((H)I)G)F;"</span>).unwrap();
<span class="kw">let </span>(sum_edge_lengths, num_edges) = tree.get_distance(
    <span class="kw-2">&amp;</span>tree.get_by_name(<span class="string">"A"</span>).unwrap().id,
    <span class="kw-2">&amp;</span>tree.get_by_name(<span class="string">"I"</span>).unwrap().id,
).unwrap();

<span class="macro">assert_eq!</span>(num_edges, <span class="number">4</span>);
<span class="macro">assert!</span>(sum_edge_lengths.is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.distance_matrix_recursive" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1490-1513">source</a><h4 class="code-header">pub fn <a href="#method.distance_matrix_recursive" class="fn">distance_matrix_recursive</a>(
    &amp;self,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../distance/struct.DistanceMatrix.html" title="struct phylotree::distance::DistanceMatrix">DistanceMatrix</a>&lt;<a class="type" href="type.Edge.html" title="type phylotree::tree::Edge">Edge</a>&gt;, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Computes the distance matrix of the tree, implemented in a recursive manner.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>tree = Tree::from_newick(<span class="string">"((T3:0.2,T1:0.2):0.3,(T2:0.4,T0:0.5):0.6);"</span>).unwrap();
<span class="kw">let </span>matrix = tree.distance_matrix_recursive().unwrap();

<span class="kw">let </span>phylip=<span class="string">"\
4
T0    0  1.6  0.9  1.6
T1    1.6  0  1.5  0.4
T2    0.9  1.5  0  1.5
T3    1.6  0.4  1.5  0
"</span>;

<span class="macro">assert_eq!</span>(phylip, matrix.to_phylip(<span class="bool-val">true</span>).unwrap())</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.distance_matrix" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1532-1627">source</a><h4 class="code-header">pub fn <a href="#method.distance_matrix" class="fn">distance_matrix</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../distance/struct.DistanceMatrix.html" title="struct phylotree::distance::DistanceMatrix">DistanceMatrix</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.f64.html">f64</a>&gt;, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Computes the distance matrix of the tree.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>tree = Tree::from_newick(<span class="string">"((T3:0.2,T1:0.2):0.3,(T2:0.4,T0:0.5):0.6);"</span>).unwrap();
<span class="kw">let </span>matrix = tree.distance_matrix().unwrap();

<span class="kw">let </span>phylip=<span class="string">"\
4
T0    0  1.6  0.9  1.6
T1    1.6  0  1.5  0.4
T2    0.9  1.5  0  1.5
T3    1.6  0.4  1.5  0
"</span>;

<span class="macro">assert_eq!</span>(phylip, matrix.to_phylip(<span class="bool-val">true</span>).unwrap())</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Tree-5" class="impl"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1634-1810">source</a><a href="#impl-Tree-5" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a></h3></section></summary><div class="docblock"><p>Methods to manipulate and alter the <a href="struct.Tree.html" title="struct phylotree::tree::Tree"><code>Tree</code></a> object.</p>
<hr />
<hr />
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.prune" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1651-1663">source</a><h4 class="code-header">pub fn <a href="#method.prune" class="fn">prune</a>(&amp;mut self, root: &amp;<a class="type" href="type.NodeId.html" title="type phylotree::tree::NodeId">NodeId</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Prune the subtree starting at a given root node.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span><span class="kw-2">mut </span>tree = Tree::from_newick(<span class="string">"((A,(C,E)D)B,((H)I)G)F;"</span>).unwrap();
<span class="kw">let </span>root_idx = tree.get_by_name(<span class="string">"G"</span>).unwrap().id;

tree.prune(<span class="kw-2">&amp;</span>root_idx);

<span class="macro">assert_eq!</span>(tree.to_newick().unwrap(), <span class="string">"((A,(C,E)D)B)F;"</span>)</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.compress" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1705-1719">source</a><h4 class="code-header">pub fn <a href="#method.compress" class="fn">compress</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Compress the tree (i.e. remove nodes with exactly 1 parent and 1 child and fuse branches together)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span><span class="kw-2">mut </span>tree = Tree::from_newick(<span class="string">"((A,(C,E)D)B,((H)I)G)F;"</span>).unwrap();
<span class="comment">// Compress F-&gt;G-&gt;I-&gt;H to F-&gt;H
</span>tree.compress().unwrap();

<span class="macro">assert_eq!</span>(tree.to_newick().unwrap(), <span class="string">"((A,(C,E)D)B,H)F;"</span>)</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rescale" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1734-1738">source</a><h4 class="code-header">pub fn <a href="#method.rescale" class="fn">rescale</a>(&amp;mut self, factor: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.f64.html">f64</a>)</h4></section></summary><div class="docblock"><p>Rescale the branch lenghts of the tree</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span><span class="kw-2">mut </span>tree = Tree::from_newick(<span class="string">"(A:0.1,B:0.2,(C:0.3,D:0.4)E:0.5)F;"</span>).unwrap();
<span class="comment">// Double all branch lengths
</span>tree.rescale(<span class="number">2.0</span>);

<span class="macro">assert_eq!</span>(
    tree.to_newick().unwrap(),
    <span class="string">"(A:0.2,B:0.4,(C:0.6,D:0.8)E:1)F;"
</span>)</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.resolve" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1751-1783">source</a><h4 class="code-header">pub fn <a href="#method.resolve" class="fn">resolve</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Randomly resolve multifurcations to binarize the tree</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span><span class="kw-2">mut </span>tree = Tree::from_newick(<span class="string">"((A:0.1,B:0.2):0.3, (C:0.1,D:0.2,E:0.4)F:0.5)G;"</span>).unwrap();
<span class="macro">assert!</span>(!tree.is_binary().unwrap());

tree.resolve();
<span class="macro">assert!</span>(tree.is_binary().unwrap());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ladderize" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1796-1809">source</a><h4 class="code-header">pub fn <a href="#method.ladderize" class="fn">ladderize</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Sort children of a node by number of descendants</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span><span class="kw-2">mut </span>tree = Tree::from_newick(<span class="string">"(A,(((D,(E,F)),C),B));"</span>).unwrap();
tree.ladderize();

<span class="macro">assert_eq!</span>(<span class="string">"(A,(B,(C,(D,(E,F)))));"</span>, tree.to_newick().unwrap());
</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Tree-6" class="impl"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1816-2162">source</a><a href="#impl-Tree-6" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a></h3></section></summary><div class="docblock"><p>Methods to read and write <a href="struct.Tree.html" title="struct phylotree::tree::Tree"><code>Tree</code></a> objects to and from files or <a href="https://doc.rust-lang.org/1.80.1/alloc/string/struct.String.html" title="struct alloc::string::String"><code>String</code></a> objects.</p>
<hr />
<hr />
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_newick" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1849-1852">source</a><h4 class="code-header">pub fn <a href="#method.to_newick" class="fn">to_newick</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Writes the tree as a newick formatted string</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>newick = <span class="string">"(A:0.1,B:0.2,(C:0.3,D:0.4)E:0.5)F:0.6;"</span>;
<span class="kw">let </span>tree = Tree::from_newick(newick).unwrap();

<span class="macro">assert_eq!</span>(tree.to_newick().unwrap(), newick);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_formatted_newick" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1873-1876">source</a><h4 class="code-header">pub fn <a href="#method.to_formatted_newick" class="fn">to_formatted_newick</a>(
    &amp;self,
    format: <a class="enum" href="enum.NewickFormat.html" title="enum phylotree::tree::NewickFormat">NewickFormat</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.80.1/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Writes the tree as a newick formatted string with a specified
output format from <a href="enum.NewickFormat.html" title="enum phylotree::tree::NewickFormat"><code>NewickFormat</code></a>.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::{Tree, NewickFormat};

<span class="kw">let </span>newick = <span class="string">"(A:0.1,B:0.2,(C:0.3,D:0.4)E:0.5)F:0.6;"</span>;
<span class="kw">let </span>tree = Tree::from_newick(newick).unwrap();

<span class="macro">assert_eq!</span>(tree.to_formatted_newick(NewickFormat::Topology).unwrap(), <span class="string">"(,,(,));"</span>);
<span class="macro">assert_eq!</span>(
    tree.to_formatted_newick(NewickFormat::OnlyNames).unwrap(),
    <span class="string">"(A,B,(C,D)E)F;"
</span>);
<span class="macro">assert_eq!</span>(
    tree.to_formatted_newick(NewickFormat::InternalLengthsLeafNames).unwrap(),
    <span class="string">"(A,B,(C,D):0.5):0.6;"
</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_newick" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#1890-2096">source</a><h4 class="code-header">pub fn <a href="#method.from_newick" class="fn">from_newick</a>(newick: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, <a class="enum" href="enum.NewickParseError.html" title="enum phylotree::tree::NewickParseError">NewickParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Read a newick formatted string and build a <a href="struct.Tree.html" title="struct phylotree::tree::Tree"><code>Tree</code></a> struct from it.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>phylotree::tree::Tree;

<span class="kw">let </span>newick = <span class="string">"(A:0.1,B:0.2,(C:0.3,D:0.4)E:0.5)F;"</span>;
<span class="kw">let </span>tree = Tree::from_newick(newick).unwrap();

<span class="macro">assert_eq!</span>(tree.size(), <span class="number">6</span>);
<span class="macro">assert_eq!</span>(tree.n_leaves(), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(tree.is_rooted().unwrap(), <span class="bool-val">false</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_file" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#2099-2104">source</a><h4 class="code-header">pub fn <a href="#method.to_file" class="fn">to_file</a>(&amp;self, path: &amp;<a class="struct" href="https://doc.rust-lang.org/1.80.1/std/path/struct.Path.html" title="struct std::path::Path">Path</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Writes the tree to a newick file</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_file" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#2107-2110">source</a><h4 class="code-header">pub fn <a href="#method.from_file" class="fn">from_file</a>(path: &amp;<a class="struct" href="https://doc.rust-lang.org/1.80.1/std/path/struct.Path.html" title="struct std::path::Path">Path</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, <a class="enum" href="enum.NewickParseError.html" title="enum phylotree::tree::NewickParseError">NewickParseError</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a tree from a newick file</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.print_debug" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#2140-2149">source</a><h4 class="code-header">pub fn <a href="#method.print_debug" class="fn">print_debug</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Print a debug view of the tree to the console</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.print" class="method"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#2152-2161">source</a><h4 class="code-header">pub fn <a href="#method.print" class="fn">print</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.unit.html">()</a>, <a class="enum" href="enum.TreeError.html" title="enum phylotree::tree::TreeError">TreeError</a>&gt;</h4></section></summary><div class="docblock"><p>Print the tree to the console</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Tree" class="impl"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#119">source</a><a href="#impl-Clone-for-Tree" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#119">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/1.80.1/src/core/clone.rs.html#169">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Tree" class="impl"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#119">source</a><a href="#impl-Debug-for-Tree" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#119">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.80.1/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.80.1/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-Tree" class="impl"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#2207-2211">source</a><a href="#impl-Default-for-Tree" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a></h3></section></summary><div class="docblock"><p>Methods to infer <a href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a> ojects from <a href="../distance/struct.DistanceMatrix.html" title="struct phylotree::distance::DistanceMatrix">DistanceMatrix</a> objects</p>
<hr />
<hr />
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../../src/phylotree/tree/tree.rs.html#2208-2210">source</a><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; Self</h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.80.1/core/default/trait.Default.html#tymethod.default">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Tree" class="impl"><a href="#impl-Freeze-for-Tree" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a></h3></section><section id="impl-RefUnwindSafe-for-Tree" class="impl"><a href="#impl-RefUnwindSafe-for-Tree" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a></h3></section><section id="impl-Send-for-Tree" class="impl"><a href="#impl-Send-for-Tree" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a></h3></section><section id="impl-Sync-for-Tree" class="impl"><a href="#impl-Sync-for-Tree" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a></h3></section><section id="impl-Unpin-for-Tree" class="impl"><a href="#impl-Unpin-for-Tree" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a></h3></section><section id="impl-UnwindSafe-for-Tree" class="impl"><a href="#impl-UnwindSafe-for-Tree" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Tree.html" title="struct phylotree::tree::Tree">Tree</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.80.1/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.80.1/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/1.80.1/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.80.1/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#768">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#758">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pointable-for-T" class="impl"><a class="src rightside" href="../../src/crossbeam_epoch/atomic.rs.html#194">source</a><a href="#impl-Pointable-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../crossbeam_epoch/atomic/trait.Pointable.html" title="trait crossbeam_epoch::atomic::Pointable">Pointable</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.ALIGN" class="associatedconstant trait-impl"><a class="src rightside" href="../../src/crossbeam_epoch/atomic.rs.html#195">source</a><a href="#associatedconstant.ALIGN" class="anchor">§</a><h4 class="code-header">const <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#associatedconstant.ALIGN" class="constant">ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a> = _</h4></section></summary><div class='docblock'>The alignment of pointer.</div></details><details class="toggle" open><summary><section id="associatedtype.Init" class="associatedtype trait-impl"><a href="#associatedtype.Init" class="anchor">§</a><h4 class="code-header">type <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#associatedtype.Init" class="associatedtype">Init</a> = T</h4></section></summary><div class='docblock'>The type for initializers.</div></details><details class="toggle method-toggle" open><summary><section id="method.init" class="method trait-impl"><a class="src rightside" href="../../src/crossbeam_epoch/atomic.rs.html#199">source</a><a href="#method.init" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.init" class="fn">init</a>(init: &lt;T as <a class="trait" href="../../crossbeam_epoch/atomic/trait.Pointable.html" title="trait crossbeam_epoch::atomic::Pointable">Pointable</a>&gt;::<a class="associatedtype" href="../../crossbeam_epoch/atomic/trait.Pointable.html#associatedtype.Init" title="type crossbeam_epoch::atomic::Pointable::Init">Init</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Initializes a with the given initializer. <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.init">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a class="src rightside" href="../../src/crossbeam_epoch/atomic.rs.html#203">source</a><a href="#method.deref" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref" class="fn">deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;'a T</a></h4></section></summary><div class='docblock'>Dereferences the given pointer. <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl"><a class="src rightside" href="../../src/crossbeam_epoch/atomic.rs.html#207">source</a><a href="#method.deref_mut" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref_mut" class="fn">deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;'a mut T</a></h4></section></summary><div class='docblock'>Mutably dereferences the given pointer. <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.deref_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a class="src rightside" href="../../src/crossbeam_epoch/atomic.rs.html#211">source</a><a href="#method.drop" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.drop" class="fn">drop</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.usize.html">usize</a>)</h4></section></summary><div class='docblock'>Drops the object pointed to by the given pointer. <a href="../../crossbeam_epoch/atomic/trait.Pointable.html#tymethod.drop">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/alloc/borrow.rs.html#83-85">source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.80.1/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.80.1/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/1.80.1/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.80.1/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.80.1/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-VZip%3CV%3E-for-T" class="impl"><a class="src rightside" href="../../src/ppv_lite86/types.rs.html#221-223">source</a><a href="#impl-VZip%3CV%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;V, T&gt; <a class="trait" href="../../ppv_lite86/types/trait.VZip.html" title="trait ppv_lite86::types::VZip">VZip</a>&lt;V&gt; for T<div class="where">where
    V: <a class="trait" href="../../ppv_lite86/types/trait.MultiLane.html" title="trait ppv_lite86::types::MultiLane">MultiLane</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.vzip" class="method trait-impl"><a class="src rightside" href="../../src/ppv_lite86/types.rs.html#226">source</a><a href="#method.vzip" class="anchor">§</a><h4 class="code-header">fn <a href="../../ppv_lite86/types/trait.VZip.html#tymethod.vzip" class="fn">vzip</a>(self) -&gt; V</h4></section></div></details></div></section></div></main></body></html>